<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Player.IO Client</name>
    </assembly>
    <members>
        <member name="T:PlayerIOClient.GameFS">
            <summary>
            Access to files stored in GameFS
            </summary>
        </member>
        <member name="M:PlayerIOClient.GameFS.GetUrl(System.String)">
            <summary>Converts a GameFS path (like '/mygame.swf') into a full url, that can be downloaded over the internet. 
            <para>Important! Do not save or otherwise persist (bigdb, cookies, etc) the returned url, since the url will change over time.</para>
            </summary>
            <param name="path">The path of the file in the GameFS, including the initial slash. Examples: '/mygame.swf' or '/characters/bob.jpg'</param>
            <returns>An url that can be used to download the resource over the internet</returns>
        </member>
        <member name="T:PlayerIOClient.BigDB">
            <summary>
            The Player.IO BigDB service.
            
            <para>This class is used to create, load, and delete database objects. All database objects are stored in tables and have a unique key. 
            You can set up tables in your admin panel, and you can also set up indexes there for when you want to load objects by properties
            or ranges of properties. Please note that all methods are asynchronous and any handling of results have to be done in a callback.
            If you don't care about the results of a method call, typically for create or delete functions, you can just pass in a null callback.</para>
            <para>Here's how to store and update an object:</para>
            <code>
            //Make new object and set some properties
            DatabaseObject obj = new DatabaseObject();
            obj.Set("username", "Adam");
            obj.Set("location", "London");
            obj.Set("age", 20);
            
            //Create object in table Users with ConnectUserId as key
            PlayerIO.BigDB.CreateObject("Users", ConnectUserId, obj, 
            	delegate (DatabaseObject result){
            		//Change a property and store the update when created
            		result.Set("location", "Paris");
            		result.Save(null);
            	}
            );
            
            </code>
            <para>This is how you load an object:</para>
            <code>
            PlayerIO.BigDB.Load("Users", ConnectUserId, delegate (DatabaseObject result){
            	if (result != null) {
            		//Change a property and save back.
            		result.Set("location", "Amsterdam");
            		result.Save(null);
            	}
            });
            </code>
            <para>In case you always want to modify an object, you can use the LoadOrCreate method to ensure you get an object back:</para>
            <code>
            PlayerIO.BigDB.LoadOrCreate("Users", ConnectUserId, 
            	delegate (DatabaseObject result){
            		if (!result.Contains("username")) {
            			//Empty object, initialize it
            			result.Set("username", "Charlie");
            			result.Set("age", 20);
            		}
            		result.Set("location", "London");
            		result.Save();
            	}
            );
            </code>
            <para>
            BigDB also supports indexes for retrieving objects by a specific property, a range of properties, 
            or to sort objects by properties. Indexes need to be set up in the admin panel for each table, 
            each index needs a name, and a list of properties, and for each property you also need to specify a
            sort order.
            </para>
            <para>Imagine that we have objects that look like this:</para>
            <code>
            {
            	username:"Adam",
            	created:2010-05-12 15:28
            	location:"London",
            	age:20,
            }
            </code>
            <para>That we have defined an index called "ByUsername" that looks like this:
            	<ul>
            		<li>{Property:"username", Type:String, Order:Ascending}</li>
            	</ul>
            </para>
            <para>And an index called "ByCreated" that looks like this:
            	<ul>
            		<li>{Property:"created", Type:Datetime, Order:Descending}</li>
            	</ul>
            </para>
            <para>Then we can do lookups like these:</para>
            <code>
            //Get the object where username="Adam"
            PlayerIO.BigDB.LoadSingle("Users", "ByUsername", new object[]{"Adam"}, 
            	delegate(DatabaseObject result) {
            		//...
            	}
            );
            
            //Get all users with usernames between "Adam" and "Charlie".
            //This would retrieve users named "Adamsson" and "Barney", 
            //but not users named "Abel" or "Charlotte".
            PlayerIO.BigDB.LoadRange("Users", "ByUsername", null, "Adam", "Charlie", 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Get all users up to and including "Adam". This would retrieve 
            //users named "Aaron" and "Ackerman", but not "Adamsson" or "Barney".
            PlayerIO.BigDB.LoadRange("Users", "ByUsername", null, null, "Adam", 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Get all users from "Xerxes". This would retrieve users named 
            //"Yngwie" and "Zed", but not "Charlie" or "Xantippa".
            PlayerIO.BigDB.LoadRange("Users", "ByUsername", null, "Xerxes", null, 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Retrieve the ten first objects by the ByCreated index. 
            //Since that index is sorted in descending order, this will actually 
            //retrieve the 10 latest created users.
            PlayerIO.BigDB.LoadRange("Users", "ByCreated", null, null, null, 10, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Get the 10 latest users that were created more than 7 days ago.
            var weekago = DateTime.Now.AddDays(-7);
            PlayerIO.BigDB.LoadRange("Users", "ByCreated", null, weekago, null, 10, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            </code>
            
            <para>
            BigDB also supports compound indexes, that is indexes with more than one property. Given our example object above, we can create an index called "ByLocationAgeCreated" that looks like this:
            	<ul>
            		<li>{Property:"location", Type:String, Order:Ascending}</li>
            		<li>{Property:"age", Type:Integer, Order:Ascending}</li>
            		<li>{Property:"created", Type:Datetime, Order:Descending}</li>
            	</ul>
            </para>
            <para>
            With this index, we can then lookup on either location, or location and age, or location and age and created. If we use more than one property in the lookup, we can only specify the range for the last one, the preceding ones have to be fixed and are sent in via the path parameter.
            </para>
            <code>
            //Load all users where location is "London"
            PlayerIO.BigDB.LoadRange("Users", "ByLocationAgeCreated", null, "London", 
            	"London", 100, delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Load all users from London between 20 and 30 years of age
            PlayerIO.BigDB.LoadRange("Users", "ByLocationAgeCreated", 
            	new object[]{"London"}, 20, 30, 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Load all users from London that are above 50
            PlayerIO.BigDB.LoadRange("Users", "ByLocationAgeCreated", 
            	new object[]{"London"}, 50, null, 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Load all users from Paris that are 30 years old, and were created in April
            PlayerIO.BigDB.LoadRange("Users", "ByLocationAgeCreated", 
            	new object[]{"Paris", 30}, new DateTime(2010, 4, 1), 
            	new DateTime(2010, 4, 30), 100, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            
            //Load the 10 latest 20-year old users from Amsterdam
            PlayerIO.BigDB.LoadRange("Users", "ByLocationAgeCreated", 
            	new object[]{"Amsterdam", 20}, null, null, 10, 
            	delegate(DatabaseObject[] result) {
            		//...
            	}
            );
            </code>
            
            <para>Finally, deleting objects is as easy as calling the DeleteKeys method, or DeleteRange if you want to delete by an index.</para>
            <code>
            //Delete current Users object.
            PlayerIO.BigDB.DeleteKeys("Users", ConnectUserId, null);
            
            //Delete all objects with usernames between "Adam" and "Charle"
            PlayerIO.BigDB.DeleteRange("Users", "ByUsername", null, "Adam", 
            	"Charlie", null);
            
            //Delete all objects with created older than one year
            PlayerIO.BigDB.DeleteRange("Users", "ByUsername", null, 
            	DateTime.Now.AddYear(-1), null, null);
            </code>
            </summary>
        </member>
        <member name="M:PlayerIOClient.BigDB.CreateObject(System.String,System.String,PlayerIOClient.DatabaseObject)">
            <summary>Creates a new database object in the given table with the specified key. If no key is specified (null), the object will receive an autogenerated id.</summary>
             <param name="table">The name of the table to create the database object in</param>
             <param name="key">The key to assign to the database object</param>
             <param name="obj">The database object to create in the table</param>
             <returns>A new instance of DatabaseObject from which .Save() can be called for future modifications.</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.CreateObject(System.String,System.String,PlayerIOClient.DatabaseObject,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject})">
            <summary>Creates a new database object in the given table with the specified key. If no key is specified (null), the object will receive an autogenerated id.</summary>
             <param name="table">The name of the table to create the database object in</param>
             <param name="key">The key to assign to the database object</param>
             <param name="obj">The database object to create in the table</param>
             <param name="successCallback">Callback to execute when the object has been created with a new instance of DatabaseObject from which .Save() can be called for future modifications.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.CreateObject(System.String,System.String,PlayerIOClient.DatabaseObject,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Creates a new database object in the given table with the specified key. If no key is specified (null), the object will receive an autogenerated id.</summary>
             <param name="table">The name of the table to create the database object in</param>
             <param name="key">The key to assign to the database object</param>
             <param name="obj">The database object to create in the table</param>
             <param name="successCallback">Callback that will be called with a new instance of DatabaseObject from which .Save() can be called for future modifications when the object has been created.</param>
             <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the object creation.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadMyPlayerObject">
            <summary>Loads the database object corresponding to the player from the PlayerObjects table</summary>
            <returns>The database object corresponding to the player in the PlayerObjects table</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadMyPlayerObject(PlayerIOClient.Callback{PlayerIOClient.DatabaseObject})">
            <summary>Loads the database object corresponding to the player from the PlayerObjects table</summary>
             <param name="successCallback">Callback with the loaded player object</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadMyPlayerObject(PlayerIOClient.Callback{PlayerIOClient.DatabaseObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads the database object corresponding to the player from the PlayerObjects table</summary>
             <param name="successCallback">Callback with the loaded player object</param>
             <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.Load(System.String,System.String)">
            <summary>Load the database object with the given key from the given table.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="key">The key of the database object to load</param>
            <returns>The database object found, or null if no object exists with the given key.</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.Load(System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject})">
            <summary>Load the database object with the given key from the given table.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="key">The key of the database object to load</param>
            <param name="successCallback">Callback with the loaded database object</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.Load(System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Load the database object with the given key from the given table.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="key">The key of the database object to load</param>
            <param name="successCallback">Callback with the loaded database object or null if no object exists with the given key</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadOrCreate(System.String,System.String)">
            <summary>Loads or creates the database object with the given key from the given table.</summary>
            <param name="table">The table from which to load or create the database object</param>
            <param name="key">The key of the database object to load or create</param>
            <returns>The database object loaded</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadOrCreate(System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject})">
            <summary>Loads or creates the database object with the given key from the given table.</summary>
            <param name="table">The table from which to load or create the database object</param>
            <param name="key">The key of the database object to load or create</param>
            <param name="successCallback">Callback with the database object</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadOrCreate(System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads or creates the database object with the given key from the given table.</summary>
            <param name="table">The table from which to load or create the database object</param>
            <param name="key">The key of the database object to load or create</param>
            <param name="successCallback">Callback with the database object</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load or create.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeys(System.String,System.String[])">
            <summary>Loads the database objects with the given keys from the given table.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <returns>An array of database objects in the same order as the keys array, with null values for non-existant database objects.</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeys(System.String,System.String[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]})">
            <summary>Loads the database objects with the given keys from the given table.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <param name="successCallback">Callback with an array of database objects in the same order as the keys array, with null values for non-existant database objects</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeys(System.String,System.String[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads the database objects with the given keys from the given table.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <param name="successCallback">Callback with an array of database objects in the same order as the keys array, with null values for non-existant database objects</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeysOrCreate(System.String,System.String[])">
            <summary>Loads or creates database objects with the given keys from the given table. New objects are created if there are no existing objects for the given keys.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <returns>An array of database objects in the same order as the keys array</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeysOrCreate(System.String,System.String[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]})">
            <summary>Loads or creates database objects with the given keys from the given table. New objects are created if there are no existing objects for the given keys.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <param name="successCallback">Callback with an array of database objects in the same order as the keys array</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadKeysOrCreate(System.String,System.String[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads or creates database objects with the given keys from the given table. New objects are created if there are no existing objects for the given keys.</summary>
            <param name="table">The table to load the database objects from</param>
            <param name="keys">They keys of the database objects to load</param>
            <param name="successCallback">Callback with an array of database objects in the same order as the keys array</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load or create.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadSingle(System.String,System.String,System.Object[])">
            <summary>Load a database object from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexValue">An array of objects of the same types as the index properties, specifying which object to load</param>
            <returns>The database object found, or null if no object was found.</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadSingle(System.String,System.String,System.Object[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject})">
            <summary>Load a database object from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexValue">An array of objects of the same types as the index properties, specifying which object to load</param>
            <param name="successCallback">Callback with the database object found, or null if no object was found</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadSingle(System.String,System.String,System.Object[],PlayerIOClient.Callback{PlayerIOClient.DatabaseObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Load a database object from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexValue">An array of objects of the same types as the index properties, specifying which object to load</param>
            <param name="successCallback">Callback with the database object found, or null if no object was found</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadRange(System.String,System.String,System.Object[],System.Object,System.Object,System.Int32)">
            <summary>Load a range of database objects from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexPath">Where in the index to start the range search: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to return. IndexPath can be set to null if there is only one property in the index.</param>
            <param name="start">Where to start the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to include in the results</param>
            <param name="stop">Where to stop the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to include in the results</param>
            <param name="limit">The max amount of objects to return</param>
            <returns>The database objects found, or null if no object was found.</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadRange(System.String,System.String,System.Object[],System.Object,System.Object,System.Int32,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]})">
            <summary>Load a range of database objects from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexPath">Where in the index to start the range search: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to return. IndexPath can be set to null if there is only one property in the index.</param>
            <param name="start">Where to start the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to include in the results</param>
            <param name="stop">Where to stop the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to include in the results</param>
            <param name="limit">The max amount of objects to return</param>
            <param name="successCallback">Callback with the database objects found, or null if no object was found</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.LoadRange(System.String,System.String,System.Object[],System.Object,System.Object,System.Int32,PlayerIOClient.Callback{PlayerIOClient.DatabaseObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Load a range of database objects from a table using the specified index.</summary>
            <param name="table">The table to load the database object from</param>
            <param name="index">The name of the index to query for the database object</param>
            <param name="indexPath">Where in the index to start the range search: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to return. IndexPath can be set to null if there is only one property in the index.</param>
            <param name="start">Where to start the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to include in the results</param>
            <param name="stop">Where to stop the range search. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to include in the results</param>
            <param name="limit">The max amount of objects to return</param>
            <param name="successCallback">Callback with the database objects found, or null if no object was found</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the load.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.SaveChanges(System.Boolean,System.Boolean,PlayerIOClient.DatabaseObject[])">
            <summary>Save changes to one or more database objects in one go.</summary>
            <param name="useOptimisticLocks">Should the save only go through, if no other process has modified the object since it was loaded?</param>
            <param name="objects">The objects with changes to save</param>
            <returns>True if the save succeded, false if not (only if using optimistic locking and newer version exists in database).</returns>
        </member>
        <member name="M:PlayerIOClient.BigDB.SaveChanges(System.Boolean,System.Boolean,PlayerIOClient.DatabaseObject[],PlayerIOClient.Callback)">
            <summary>Save changes to one or more database objects in one go.</summary>
            <param name="useOptimisticLocks">Should the save only go through, if no other process has modified the object since it was loaded?</param>
            <param name="objects">The objects with changes to save</param>
            <param name="successCallback">Callback with true if the save succeded and false if it failed (only if using optimistic locking and newer version exists in database)</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.SaveChanges(System.Boolean,System.Boolean,PlayerIOClient.DatabaseObject[],PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Save changes to one or more database objects in one go.</summary>
            <param name="useOptimisticLocks">Should the save only go through, if no other process has modified the object since it was loaded?</param>
            <param name="objects">The objects with changes to save</param>
            <param name="successCallback">Callback with true if the save succeded and false if it failed (only if using optimistic locking and newer version exists in database)</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the save.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteKeys(System.String,System.String[])">
            <summary>Delete a set of database objects from a table</summary>
            <param name="table">The table to delete the database objects from</param>
            <param name="keys">The keys of the database objects to delete</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteKeys(System.String,System.String[],PlayerIOClient.Callback)">
            <summary>Delete a set of database objects from a table</summary>
            <param name="table">The table to delete the database objects from</param>
            <param name="keys">The keys of the database objects to delete</param>
            <param name="successCallback">Callback when the deletion has completed.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteKeys(System.String,System.String[],PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Delete a set of database objects from a table</summary>
            <param name="table">The table to delete the database objects from</param>
            <param name="keys">The keys of the database objects to delete</param>
            <param name="successCallback">Callback when the deletion has completed.</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the deletion.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteRange(System.String,System.String,System.Object[],System.Object,System.Object)">
            <summary>Delete a range of database objects from a table using an index</summary>
            <param name="table">The table to delete the database object from</param>
            <param name="index">The name of the index to query for the database objects to delete</param>
            <param name="indexPath">Where in the index to start the range delete: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to delete. IndexPath can be set to null instead of an empty array.</param>
            <param name="start">Where to start the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to delete</param>
            <param name="stop">Where to stop the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to delete</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteRange(System.String,System.String,System.Object[],System.Object,System.Object,PlayerIOClient.Callback)">
            <summary>Delete a range of database objects from a table using an index</summary>
            <param name="table">The table to delete the database object from</param>
            <param name="index">The name of the index to query for the database objects to delete</param>
            <param name="indexPath">Where in the index to start the range delete: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to delete. IndexPath can be set to null instead of an empty array.</param>
            <param name="start">Where to start the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to delete</param>
            <param name="stop">Where to stop the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to delete</param>
            <param name="successCallback">Callback when the deletion has completed.</param>
        </member>
        <member name="M:PlayerIOClient.BigDB.DeleteRange(System.String,System.String,System.Object[],System.Object,System.Object,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Delete a range of database objects from a table using an index</summary>
            <param name="table">The table to delete the database object from</param>
            <param name="index">The name of the index to query for the database objects to delete</param>
            <param name="indexPath">Where in the index to start the range delete: An array of objects of the same types as the index properties, specifying where in the index to start loading database objects from. For instance, in the index [Mode,Map,Score] you might use new object[]{"expert","skyland"} as the indexPath and use the start and stop arguments to determine the range of scores you wish to delete. IndexPath can be set to null instead of an empty array.</param>
            <param name="start">Where to start the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then start defines the minimum score to delete</param>
            <param name="stop">Where to stop the range delete. For instance, if the index is [Mode,Map,Score] and indexPath is ["expert","skyland"], then stop defines the maximum score to delete</param>
            <param name="successCallback">Callback when the deletion has completed.</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the deletion.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.Connect(System.String,System.String,System.String,System.String)">
            <summary>Returns a token that can be used to work with PlayerIO methods in the future</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="connectionId">The id of the connection, as given in the settings section of the admin panel. 'public' should be used as the default</param>
            <param name="userId">The id of the user connecting. This can be any string you like.</param>
            <param name="auth">If the connection identified by ConnectionIdentifier only accepts authenticated requests, the auth value generated based on UserId is added here</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.Connect(System.String,System.String,System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.ConnectOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Returns a token that can be used to work with PlayerIO methods in the future</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="connectionId">The id of the connection, as given in the settings section of the admin panel. 'public' should be used as the default</param>
            <param name="userId">The id of the user connecting. This can be any string you like.</param>
            <param name="auth">If the connection identified by ConnectionIdentifier only accepts authenticated requests, the auth value generated based on UserId is added here</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnect(System.String,System.String,System.String)">
            <summary>Authenticates a user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="usernameOrEmail">The username or email of the user you wish to authenticate.</param>
            <param name="password">The password of the user you wish to authenticate.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnect(System.String,System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Authenticates a user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="usernameOrEmail">The username or email of the user you wish to authenticate.</param>
            <param name="password">The password of the user you wish to authenticate.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptcha(System.String,System.Int32,System.Int32)">
            <summary>Creates a Captcha image and key, to be used for registrations where the added security of Captcha is required..</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="width">The width of the Captcha image.</param>
            <param name="height">The height of the Captcha image.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptcha(System.String,System.Int32,System.Int32,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Creates a Captcha image and key, to be used for registrations where the added security of Captcha is required..</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="width">The width of the Captcha image.</param>
            <param name="height">The height of the Captcha image.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegister(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Registers a new user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="username">The username of the new user.</param>
            <param name="password">The password of the new user.</param>
            <param name="email">The email of the new user. (optional)</param>
            <param name="captchaKey">(only if captcha is required) The key of the Captcha image used to get the user to write in the Captcha value</param>
            <param name="captchaValue">(only if captcha is required) The string the user entered in response to the captcha image</param>
            <param name="extraData">Any extra data that you wish to store with the user such as gender, birthdate, etc. (optional)</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegister(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String},PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIORegistrationError})">
            <summary>Registers a new user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="username">The username of the new user.</param>
            <param name="password">The password of the new user.</param>
            <param name="email">The email of the new user. (optional)</param>
            <param name="captchaKey">(only if captcha is required) The key of the Captcha image used to get the user to write in the Captcha value</param>
            <param name="captchaValue">(only if captcha is required) The string the user entered in response to the captcha image</param>
            <param name="extraData">Any extra data that you wish to store with the user such as gender, birthdate, etc. (optional)</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleRecoverPassword(System.String,System.String)">
            <summary>Initiates the password recovery process for a user. The user must have supplied an email address during registration.</summary>
            <param name="gameId">The game id of the game the user is registered in.</param>
            <param name="usernameOrEmail">The username or email address of the user that wishes to recover his password.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SimpleRecoverPassword(System.String,System.String,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Initiates the password recovery process for a user. The user must have supplied an email address during registration.</summary>
            <param name="gameId">The game id of the game the user is registered in.</param>
            <param name="usernameOrEmail">The username or email address of the user that wishes to recover his password.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnect(System.String,System.String,System.String)">
            <summary>Authenticates a Facebook user and session and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="uid">The Facebook uid of the user you wish to authenticate.</param>
            <param name="sessionKey">The Facebook session key of the user's session.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnect(System.String,System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Authenticates a Facebook user and session and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="uid">The Facebook uid of the user you wish to authenticate.</param>
            <param name="sessionKey">The Facebook session key of the user's session.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnect(System.String,System.String,System.String)">
            <summary>Authenticates a Kongregate user and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="userId">The Kongregate user id of the user you wish to authenticate.</param>
            <param name="gameAuthToken">The Kongregate game auth token of the user's session.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnect(System.String,System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Authenticates a Kongregate user and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="userId">The Kongregate user id of the user you wish to authenticate.</param>
            <param name="gameAuthToken">The Kongregate game auth token of the user's session.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnect(System.String,System.String)">
            <summary>Authenticates a Facebook access_token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="accessToken">The Facebook access_token you wish to authenticate with.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnect(System.String,System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Authenticates a Facebook access_token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="accessToken">The Facebook access_token you wish to authenticate with.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>Create an multiplayer room on the Player.IO infrastructure</summary>
            <param name="roomId">The id you wish to assign to your new room - You can use this to connect to the specific room later as long as it still exists</param>
            <param name="serverType">The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">Should the room be visible when listing rooms with GetRooms</param>
            <param name="roomData">The data to initialize the room with, this can be read with ListRooms and changed from the serverside</param>
            <param name="isDevRoom">Should the room be created in the global roomlist, or in the roomlist for the development server?</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean,PlayerIOClient.Callback{System.String},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Create an multiplayer room on the Player.IO infrastructure</summary>
            <param name="roomId">The id you wish to assign to your new room - You can use this to connect to the specific room later as long as it still exists</param>
            <param name="serverType">The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">Should the room be visible when listing rooms with GetRooms</param>
            <param name="roomData">The data to initialize the room with, this can be read with ListRooms and changed from the serverside</param>
            <param name="isDevRoom">Should the room be created in the global roomlist, or in the roomlist for the development server?</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.JoinRoom(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>Join a running multiplayer room</summary>
            <param name="roomId">The id of the room you wish to connect to</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <param name="isDevRoom">Set to true to look for the room in the development roomlist and not in the games global roomlist.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.JoinRoom(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.JoinRoomOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Join a running multiplayer room</summary>
            <param name="roomId">The id of the room you wish to connect to</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <param name="isDevRoom">Set to true to look for the room in the development roomlist and not in the games global roomlist.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.ListRooms(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32,System.Int32,System.Boolean)">
            <summary>List the currently running multiplayer rooms</summary>
            <param name="serverType">The type of room you wish to list</param>
            <param name="searchCriteria">Only rooms with the same values in their roomdata will be returned</param>
            <param name="resultLimit">The maximum amount of rooms you want to receive. Use 0 for 'as many as possible'.</param>
            <param name="resultOffset">The offset into the list you wish</param>
            <param name="onlyDevRooms">Set to true to list rooms in the development roomlist, rather than from the games global roomlist.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.ListRooms(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32,System.Int32,System.Boolean,PlayerIOClient.Callback{PlayerIOClient.RoomInfo[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>List the currently running multiplayer rooms</summary>
            <param name="serverType">The type of room you wish to list</param>
            <param name="searchCriteria">Only rooms with the same values in their roomdata will be returned</param>
            <param name="resultLimit">The maximum amount of rooms you want to receive. Use 0 for 'as many as possible'.</param>
            <param name="resultOffset">The offset into the list you wish</param>
            <param name="onlyDevRooms">Set to true to list rooms in the development roomlist, rather than from the games global roomlist.</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean)">
            <summary>Creates a multiplayer room (if it does not exist already) and joins it.</summary>
            <param name="roomId">The id of the room you wish to create/join</param>
            <param name="serverType">If the room dosn't exist: The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">If the room dosn't exist: Should the room be visible when listing rooms with GetRooms upon creation</param>
            <param name="roomData">If the room dosn't exist: The data to initialize the room with upon creation</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <param name="isDevRoom">Is the room being created/joined running on a development server?</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String},System.Boolean,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Creates a multiplayer room (if it does not exist already) and joins it.</summary>
            <param name="roomId">The id of the room you wish to create/join</param>
            <param name="serverType">If the room dosn't exist: The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">If the room dosn't exist: Should the room be visible when listing rooms with GetRooms upon creation</param>
            <param name="roomData">If the room dosn't exist: The data to initialize the room with upon creation</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <param name="isDevRoom">Is the room being created/joined running on a development server?</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfo(System.String)">
            <summary>A game server wants to load the init data for a room</summary>
            <param name="extendedRoomId"></param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfo(System.String,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfoOutput},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>A game server wants to load the init data for a room</summary>
            <param name="extendedRoomId"></param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.UpdateRoom(System.String,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>A game server wants to update a room</summary>
            <param name="extendedRoomId"></param>
            <param name="visible">0=Hidden, 1=Visible, 2=NoChange</param>
            <param name="roomData">Changed room data for the room (if null, nothing changes)</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.UpdateRoom(System.String,System.Int32,System.Collections.Generic.Dictionary{System.String,System.String},PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>A game server wants to update a room</summary>
            <param name="extendedRoomId"></param>
            <param name="visible">0=Hidden, 1=Visible, 2=NoChange</param>
            <param name="roomData">Changed room data for the room (if null, nothing changes)</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.UserLeftRoom(System.String,System.Int32,System.Boolean)">
            <summary>A game server is reporting that a user left a game</summary>
            <param name="extendedRoomId"></param>
            <param name="newPlayerCount"></param>
            <param name="closed"></param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.UserLeftRoom(System.String,System.Int32,System.Boolean,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>A game server is reporting that a user left a game</summary>
            <param name="extendedRoomId"></param>
            <param name="newPlayerCount"></param>
            <param name="closed"></param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DevServerKeepAlive(System.String[])">
            <summary>Keep alive for games running on the development server</summary>
            <param name="runningExtendedRoomIds"></param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DevServerKeepAlive(System.String[],PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Keep alive for games running on the development server</summary>
            <param name="runningExtendedRoomIds"></param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerError(System.String,System.String,System.String,System.String)">
            <summary>Logs an error from the development server.</summary>
            <param name="machineName"></param>
            <param name="message"></param>
            <param name="stacktrace"></param>
            <param name="version"></param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerError(System.String,System.String,System.String,System.String,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Logs an error from the development server.</summary>
            <param name="machineName"></param>
            <param name="message"></param>
            <param name="stacktrace"></param>
            <param name="version"></param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.WriteError(System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Writes an entry to the games error log</summary>
            <param name="source">Where did the error come from? For instance, if you're writing the error from a flash file, the source might be 'flash' while errors from multiplayer code could be saved under 'multiplayer code'</param>
            <param name="error">A short string describing the error without details. Example 'Object not set to instance of an object'</param>
            <param name="details">The message describing the error in detail. Example 'couldn't find the user 'bob' in the current game'</param>
            <param name="stacktrace">The stacktrace (if available) of the error</param>
            <param name="extraData">Any extra data you'd like to associate with the error log entry</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.WriteError(System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String},PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Writes an entry to the games error log</summary>
            <param name="source">Where did the error come from? For instance, if you're writing the error from a flash file, the source might be 'flash' while errors from multiplayer code could be saved under 'multiplayer code'</param>
            <param name="error">A short string describing the error without details. Example 'Object not set to instance of an object'</param>
            <param name="details">The message describing the error in detail. Example 'couldn't find the user 'bob' in the current game'</param>
            <param name="stacktrace">The stacktrace (if available) of the error</param>
            <param name="extraData">Any extra data you'd like to associate with the error log entry</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateObjects(PlayerIOClient.Internal.PlayerIOChannel.NewBigDBObject[],System.Boolean)">
            <summary>Creates a new database object in the given table with the specified key. If no key is specified (null), the object will receive an autogenerated id.</summary>
            <param name="objects">The objects to create</param>
            <param name="loadExisting">Load existing objects if they already exists, instead of throwing an error</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.CreateObjects(PlayerIOClient.Internal.PlayerIOChannel.NewBigDBObject[],System.Boolean,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.BigDBObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Creates a new database object in the given table with the specified key. If no key is specified (null), the object will receive an autogenerated id.</summary>
            <param name="objects">The objects to create</param>
            <param name="loadExisting">Load existing objects if they already exists, instead of throwing an error</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadObjects(PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId[])">
            <summary>Load database objects</summary>
            <param name="objectIds">Identifiers for the objects to load</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadObjects(PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId[],PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.BigDBObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Load database objects</summary>
            <param name="objectIds">Identifiers for the objects to load</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChanges(PlayerIOClient.Internal.PlayerIOChannel.LockType,PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset[],System.Boolean)">
            <summary>Saves changes to database objects that already exists in BigDB.</summary>
            <param name="lockType">Which kind of lock to use when performing the save</param>
            <param name="changesets">The list of changes to apply to the database</param>
            <param name="createIfMissing">Create objects based on the changesets if there are no existings objects to modify</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChanges(PlayerIOClient.Internal.PlayerIOChannel.LockType,PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset[],System.Boolean,PlayerIOClient.Callback{System.String[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Saves changes to database objects that already exists in BigDB.</summary>
            <param name="lockType">Which kind of lock to use when performing the save</param>
            <param name="changesets">The list of changes to apply to the database</param>
            <param name="createIfMissing">Create objects based on the changesets if there are no existings objects to modify</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DeleteObjects(PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId[])">
            <summary>Deletes the specified database objects</summary>
            <param name="objectIds">Identifiers for the objects to load</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DeleteObjects(PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId[],PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Deletes the specified database objects</summary>
            <param name="objectIds">Identifiers for the objects to load</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadMyPlayerObject">
            <summary>Loads the database object corresponding to the player from the PlayerObjects table</summary>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadMyPlayerObject(PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.BigDBObject},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads the database object corresponding to the player from the PlayerObjects table</summary>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjects(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],System.Int32)">
            <summary>Loads database objects from the specificed table index whose index value matches the given value.</summary>
            <param name="table">The table containing the database objects to locate</param>
            <param name="index">The index to perform the lookup in</param>
            <param name="indexValue">The value to locate in the index</param>
            <param name="limit">The maximum amount of database objects to load</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjects(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],System.Int32,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.BigDBObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Loads database objects from the specificed table index whose index value matches the given value.</summary>
            <param name="table">The table containing the database objects to locate</param>
            <param name="index">The index to perform the lookup in</param>
            <param name="indexValue">The value to locate in the index</param>
            <param name="limit">The maximum amount of database objects to load</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRange(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],System.Int32)">
            <summary>Load database objects from the specified table index whose index value is inside the range between start and stop (both inclusive).</summary>
            <param name="table">The table containing the database objects to locate</param>
            <param name="index">The index to perform the lookup in</param>
            <param name="startIndexValue">The value to start the range search at</param>
            <param name="stopIndexValue">The value to end the range search at</param>
            <param name="limit">The maximum amount of entries to load</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRange(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],System.Int32,PlayerIOClient.Callback{PlayerIOClient.Internal.PlayerIOChannel.BigDBObject[]},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Load database objects from the specified table index whose index value is inside the range between start and stop (both inclusive).</summary>
            <param name="table">The table containing the database objects to locate</param>
            <param name="index">The index to perform the lookup in</param>
            <param name="startIndexValue">The value to start the range search at</param>
            <param name="stopIndexValue">The value to end the range search at</param>
            <param name="limit">The maximum amount of entries to load</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRange(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],PlayerIOClient.Internal.PlayerIOChannel.ValueObject[])">
            <summary>Delete all database objects from the specified table index whose index value is inside the range between start and stop (both inclusive).</summary>
            <param name="table">The table containing the database objects to delete</param>
            <param name="index">The index to perform the delete by</param>
            <param name="startIndexValue">The value to start the range search at</param>
            <param name="stopIndexValue">The value to end the range search at</param>
        </member>
        <member name="M:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRange(System.String,System.String,PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],PlayerIOClient.Internal.PlayerIOChannel.ValueObject[],PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Delete all database objects from the specified table index whose index value is inside the range between start and stop (both inclusive).</summary>
            <param name="table">The table containing the database objects to delete</param>
            <param name="index">The index to perform the delete by</param>
            <param name="startIndexValue">The value to start the range search at</param>
            <param name="stopIndexValue">The value to end the range search at</param>
            <param name="onSuccess">Callback method to be executed when request completes successfully</param>
            <param name="onError">Callback method to be executed if request fails</param>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectArgs.ConnectionId">
            <summary>The id of the connection, as given in the settings section of the admin panel. 'public' should be used as the default</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectArgs.UserId">
            <summary>The id of the user connecting. This can be any string you like.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectArgs.Auth">
            <summary>If the connection identified by ConnectionIdentifier only accepts authenticated requests, the auth value generated based on UserId is added here</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectOutput.UserId">
            <summary>The connection id used to establish the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ConnectOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectArgs.UsernameOrEmail">
            <summary>The username or email of the user you wish to authenticate.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectArgs.Password">
            <summary>The password of the user you wish to authenticate.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectOutput.UserId">
            <summary>The ConnectUserId for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleConnectOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaArgs.Width">
            <summary>The width of the Captcha image.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaArgs.Height">
            <summary>The height of the Captcha image.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaOutput.CaptchaKey">
            <summary>The key for this captcha image. This value must be kept and sent to the simpleRegister() method along with the string from the user</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleGetCaptchaOutput.CaptchaImageUrl">
            <summary>An url for the captcha image. You must show the image to the user, and ask what text is shown in the image.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.Username">
            <summary>The username of the new user.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.Password">
            <summary>The password of the new user.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.Email">
            <summary>The email of the new user. (optional)</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.CaptchaKey">
            <summary>(only if captcha is required) The key of the Captcha image used to get the user to write in the Captcha value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.CaptchaValue">
            <summary>(only if captcha is required) The string the user entered in response to the captcha image</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterArgs.ExtraData">
            <summary>Any extra data that you wish to store with the user such as gender, birthdate, etc. (optional)</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KeyValuePair.Key">
            <summary>The key</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KeyValuePair.Value">
            <summary>The value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterOutput.UserId">
            <summary>The ConnectUserId for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRegisterOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRecoverPasswordArgs.GameId">
            <summary>The game id of the game the user is registered in.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SimpleRecoverPasswordArgs.UsernameOrEmail">
            <summary>The username or email address of the user that wishes to recover his password.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectArgs.Uid">
            <summary>The Facebook uid of the user you wish to authenticate.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectArgs.SessionKey">
            <summary>The Facebook session key of the user's session.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectOutput.UserId">
            <summary>The ConnectUserId for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookConnectOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectArgs.UserId">
            <summary>The Kongregate user id of the user you wish to authenticate.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectArgs.GameAuthToken">
            <summary>The Kongregate game auth token of the user's session.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectOutput.UserId">
            <summary>The ConnectUserId for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.KongregateConnectOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectArgs.GameId">
            <summary>The game id of the game you wish to connect to. This value can be found in the admin panel</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectArgs.AccessToken">
            <summary>The Facebook access_token you wish to authenticate with.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput.Token">
            <summary>The connection token for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput.UserId">
            <summary>The ConnectUserId for the connection</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput.ShowBranding">
            <summary>Show the Player.IO branding when the client connects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput.GameFSRedirectMap">
            <summary>The GameFS redirect map</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.FacebookOAuthConnectOutput.FacebookUserId">
            <summary>The facebook userid of the connected user</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomArgs.RoomId">
            <summary>The id you wish to assign to your new room - You can use this to connect to the specific room later as long as it still exists</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomArgs.ServerType">
            <summary>The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomArgs.Visible">
            <summary>Should the room be visible when listing rooms with GetRooms</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomArgs.RoomData">
            <summary>The data to initialize the room with, this can be read with ListRooms and changed from the serverside</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomArgs.IsDevRoom">
            <summary>Should the room be created in the global roomlist, or in the roomlist for the development server?</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateRoomOutput.RoomId">
            <summary>The id of the room which was created</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.JoinRoomArgs.RoomId">
            <summary>The id of the room you wish to connect to</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.JoinRoomArgs.JoinData">
            <summary>Data to send to the room with additional information about the join </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.JoinRoomArgs.IsDevRoom">
            <summary>Set to true to look for the room in the development roomlist and not in the games global roomlist.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.JoinRoomOutput.JoinKey">
            <summary>The key that must be used to join the room on the server</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.JoinRoomOutput.Endpoints">
            <summary>The endpoints where the server running the room can be reached</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ServerEndpoint.Address">
            <summary>The address/hostname of the server</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ServerEndpoint.Port">
            <summary>The port of the server</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsArgs.ServerType">
            <summary>The type of room you wish to list</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsArgs.SearchCriteria">
            <summary>Only rooms with the same values in their roomdata will be returned</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsArgs.ResultLimit">
            <summary>The maximum amount of rooms you want to receive. Use 0 for 'as many as possible'.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsArgs.ResultOffset">
            <summary>The offset into the list you wish</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsArgs.OnlyDevRooms">
            <summary>Set to true to list rooms in the development roomlist, rather than from the games global roomlist.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ListRoomsOutput.Rooms">
            <summary>Rooms matching the search criteria</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.RoomInfo.Id">
            <summary>The id of the room</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.RoomInfo.ServerType">
            <summary>The name of the server type the room is running</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.RoomInfo.OnlineUsers">
            <summary>How many users are currently in the room</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.RoomInfo.RoomData">
            <summary>The current room data for the room</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.RoomId">
            <summary>The id of the room you wish to create/join</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.ServerType">
            <summary>If the room dosn't exist: The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.Visible">
            <summary>If the room dosn't exist: Should the room be visible when listing rooms with GetRooms upon creation</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.RoomData">
            <summary>If the room dosn't exist: The data to initialize the room with upon creation</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.JoinData">
            <summary>Data to send to the room with additional information about the join </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomArgs.IsDevRoom">
            <summary>Is the room being created/joined running on a development server?</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomOutput.RoomId">
            <summary>The id of the room which was created</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomOutput.JoinKey">
            <summary>The key that must be used to join the room on the server</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateJoinRoomOutput.Endpoints">
            <summary>The endpoints where the server can be reached</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfoArgs.ExtendedRoomId">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfoOutput.RoomData">
            <summary>The room data for the room</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfoOutput.PlayerIOToken">
            <summary>The Player.IO Token the room must use to communicate with Player.IO</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.GetRoomInfoOutput.Visible">
            <summary>Is the room visible or hidden in the roomlist?</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UpdateRoomArgs.ExtendedRoomId">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UpdateRoomArgs.Visible">
            <summary>0=Hidden, 1=Visible, 2=NoChange</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UpdateRoomArgs.RoomData">
            <summary>Changed room data for the room (if null, nothing changes)</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UserLeftRoomArgs.ExtendedRoomId">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UserLeftRoomArgs.NewPlayerCount">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.UserLeftRoomArgs.Closed">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DevServerKeepAliveArgs.RunningExtendedRoomIds">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerErrorArgs.MachineName">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerErrorArgs.Message">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerErrorArgs.Stacktrace">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.PostDevServerErrorArgs.Version">
            <summary></summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.WriteErrorArgs.Source">
            <summary>Where did the error come from? For instance, if you're writing the error from a flash file, the source might be 'flash' while errors from multiplayer code could be saved under 'multiplayer code'</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.WriteErrorArgs.Error">
            <summary>A short string describing the error without details. Example 'Object not set to instance of an object'</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.WriteErrorArgs.Details">
            <summary>The message describing the error in detail. Example 'couldn't find the user 'bob' in the current game'</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.WriteErrorArgs.Stacktrace">
            <summary>The stacktrace (if available) of the error</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.WriteErrorArgs.ExtraData">
            <summary>Any extra data you'd like to associate with the error log entry</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateObjectsArgs.Objects">
            <summary>The objects to create</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateObjectsArgs.LoadExisting">
            <summary>Load existing objects if they already exists, instead of throwing an error</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.NewBigDBObject.Table">
            <summary>The table to create the object in</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.NewBigDBObject.Key">
            <summary>The key of the object, null if an auto generated id should be used</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.NewBigDBObject.Properties">
            <summary>The properties on the object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ObjectProperty.Name">
            <summary>The name of the property</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ObjectProperty.Value">
            <summary>The value of the property</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.ValueType">
            <summary>The type of the value contained within.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.String">
            <summary>String Value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.Int">
            <summary>Integer Value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.UInt">
            <summary>Long Value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.Long">
            <summary>String Value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.Bool">
            <summary>String Value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.Float">
            <summary>The value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.Double">
            <summary>The value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.ByteArray">
            <summary>The value</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.DateTime">
            <summary>The date/time in seconds since unix epoc</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.ArrayProperties">
            <summary>The array values, if the value is an array</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ValueObject.ObjectProperties">
            <summary>A database object (only the properties)</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ArrayProperty.Index">
            <summary>The name of the property</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.ArrayProperty.Value">
            <summary>The value of the property</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.CreateObjectsOutput.Objects">
            <summary>The and version for the created objects. Note that the properties aren't sent back: the client must set the properties, instead of the server sending them back needlessly.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObject.Key">
            <summary>The key of the object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObject.Version">
            <summary>A version identifier, for optimistic locking</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObject.Properties">
            <summary>The properties on the object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObject.Creator">
            <summary>The id of the creator of the object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadObjectsArgs.ObjectIds">
            <summary>Identifiers for the objects to load</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId.Table">
            <summary>The table containing the database object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBObjectId.Keys">
            <summary>The key(s) of the databse object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadObjectsOutput.Objects">
            <summary>The loaded database objects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChangesArgs.LockType">
            <summary>Which kind of lock to use when performing the save</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChangesArgs.Changesets">
            <summary>The list of changes to apply to the database</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChangesArgs.CreateIfMissing">
            <summary>Create objects based on the changesets if there are no existings objects to modify</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset.Table">
            <summary>The table containing the database object to modify</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset.Key">
            <summary>The key of the object to modify</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset.OnlyIfVersion">
            <summary>If not null, the update will only happen if the version of the stored object is the same as this value, for optimistic locking.</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.BigDBChangeset.Changes">
            <summary>A changeset for modifications of the database object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.SaveObjectChangesOutput.Versions">
            <summary>The new versions of the database objects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DeleteObjectsArgs.ObjectIds">
            <summary>Identifiers for the objects to load</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMyPlayerObjectOutput.PlayerObject">
            <summary>The loaded player database object</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjectsArgs.Table">
            <summary>The table containing the database objects to locate</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjectsArgs.Index">
            <summary>The index to perform the lookup in</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjectsArgs.IndexValue">
            <summary>The value to locate in the index</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjectsArgs.Limit">
            <summary>The maximum amount of database objects to load</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadMatchingObjectsOutput.Objects">
            <summary>The loaded database objects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeArgs.Table">
            <summary>The table containing the database objects to locate</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeArgs.Index">
            <summary>The index to perform the lookup in</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeArgs.StartIndexValue">
            <summary>The value to start the range search at</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeArgs.StopIndexValue">
            <summary>The value to end the range search at</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeArgs.Limit">
            <summary>The maximum amount of entries to load</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.LoadIndexRangeOutput.Objects">
            <summary>The loaded database objects</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRangeArgs.Table">
            <summary>The table containing the database objects to delete</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRangeArgs.Index">
            <summary>The index to perform the delete by</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRangeArgs.StartIndexValue">
            <summary>The value to start the range search at</summary>
        </member>
        <member name="P:PlayerIOClient.Internal.PlayerIOChannel.DeleteIndexRangeArgs.StopIndexValue">
            <summary>The value to end the range search at</summary>
        </member>
        <member name="T:PlayerIOClient.DatabaseObject">
            <summary>
            This class represents a BigDB Database Object that has a Key and a collection of named properties.
            <para>There are methods for setting, getting, and removing properties, and changes to the object can be persisted to BigDB with the Save() method.</para>
            <para>Database objects are very similar to JSON objects and are most easily visualized as such. For example, we can visualize a car object like this:</para>
            <code>
            'car20312' = {
            	Name: 'OldSpeedy',
            	Stats:{
            		Acceleration: 3.2,
            		TopSpeed: 50,
            		Steering: 5,
            		WorkingBreaks:false
            	}
            	LatestLapTimes: ['20:34','22:03','22:30']
            }
            </code>
            <para>If we then want to create this object in BigDB, we would have to do this:</para>
            <code>
            DatabaseObject car = new DatabaseObject();
            car.Set("Name", "OldSpeedy");
            
            //Create nested stats object
            DatabaseObject stats = new DatabaseObject();
            stats.Set("Acceleration", 3.2);
            stats.Set("TopSpeed", 50);
            stats.Set("Steering", 5);
            stats.Set("WorkingBreaks", false);
            car.Set("Stats", stats);
            
            //Create laptimes array
            DatabaseArray laptimes = new DatabaseArray();
            laptimes.Add("20:34");
            laptimes.Add("22:03");
            laptimes.Add("22:30");
            car.Set("LatestLapTimes", laptimes);
            
            //Save car to table "Cars" under key "car20312"
            PlayerIO.BigDB.CreateObject("Cars", "car20312", car, null);
            </code>
            <para>To make it easier to work with nested objects, you can reference them directly by separating the property names with a dot. Using this, we can set the stats properties of the car like this instead:</para>
            <code>
            DatabaseObject car = new DatabaseObject();
            car.Set("Stats.Acceleration", 3.2);
            car.Set("Stats.TopSpeed", 50);
            car.Set("Stats.Steering", 5);
            car.Set("Stats.WorkingBreaks", false);
            </code>
            
            <para>When you want to read properties from a database object, you have to call the corresponding get method indicating the type of the property.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car20312", delegate(DatabaseObject car) {
            	string name = car.GetString("Name");
            	float acceleration = car.GetFloat("Stats.Acceleration");
            	int topspeed = car.GetInt("Stats.TopSpeed");
            });
            </code>
            
            <para>BigDB doesn't enforce anything on your objects. Two objects in the same table do not need to have the same properties set, and do not need to have the same type on the same property. If you try to get a property that is missing, or if you are using a get method of the wrong type, you will get an exception.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car20312", delegate(DatabaseObject car) {
            	//Name is a string, throws exception!
            	int name = car.GetInt("Name"); 
            	//Color does not exist, throws exception!
            	string color = car.GetString("Color"); 
            });
            </code>
            
            <para>One way of avoiding this is to first check the object if a certain property exists before reading this. You can do this with the Contains method.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car20312", delegate(DatabaseObject car) {
            	if (!car.Contains("Name")) {
            		car.Set("Name", "Unknown");
            	}
            	if (car.Contains("Stats.Steering")) {
            		//...
            	}
            });
            </code>
            
            <para>Another way of avoiding errors is to specify a default value when calling a get method. If the object doesn't contain the property, the method will return your default value instead.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car20312", delegate(DatabaseObject car) {
            	string color = car.GetString("Color", "Red");
            });
            </code>
            
            <para>You can also easily remove properties from your object with the Remove method.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car20312", delegate(DatabaseObject car) {
            	car.Remove("Name");
            	car.Remove("Stats.TopSpeed");
            	if (!car.Contains("Name")) {
            		//Name property should be removed now.
            	}
            });
            </code>
            
            
            <para>Finally, to persist any changes you've made to an object you can call the Save method. Note that you can only call Save on an object that exist in the database. This means that the first time you save an object you have to call the PlayerIO.BigDB.CreateObject method, but all subsequent times you can call the Save method. There is also a property called ExistsInDatabase that you can use to check if it has been created or not.</para>
            <code>
            car.Set("Name", "NewSpeedy");
            car.Set("Stats.Acceleration", 5.0);
            if (car.ExistsInDatabase) {
            	car.Save();
            } else {
            	PlayerIO.BigDB.CreateObject("Cars", "car12345", null);
            }
            </code>
            
            <para>The Save method is asynchronous just like the CreateObject method in PlayerIO.BigDB, and you can specify a callback if you wish to do something when the object actually has been saved.</para>
            <code>
            car.Set("Name", "NewSpeedy");
            car.Set("Stats.Acceleration", 5.0);
            car.Save(delegate() {
            	//On successful save...
            });
            </code>
            
            </summary>
        </member>
        <member name="F:PlayerIOClient.DatabaseObject.Table">
            <summary>The name of the BigDB table this object belongs to</summary>
        </member>
        <member name="F:PlayerIOClient.DatabaseObject.Key">
            <summary>The key of the object.</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save">
            <summary>Persist the object to the database</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean)">
            <summary>Persist the object to the database, using optimistic locking if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean,System.Boolean)">
            <summary>Persist the object to the database, using optimistic locking and full overwrite if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
            <param name="fullOverwrite">Will completely overwrite the database object in BigDB with the properties in this instance, instead of just sending the changed properties to the server.</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(PlayerIOClient.Callback)">
            <summary>Persist the object to the database</summary>
            <param name="successCallback">Callback when the save succeeds</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Persist the object to the database</summary>
            <param name="successCallback">Callback when the save succeeds</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the save.</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean,PlayerIOClient.Callback)">
            <summary>Persist the object to the database, using optimistic locking if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
            <param name="successCallback">Callback when the save succeeds</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Persist the object to the database, using optimistic locking if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
            <param name="successCallback">Callback when the save succeeds</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the save.</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean,System.Boolean,PlayerIOClient.Callback)">
            <summary>Persist the object to the database, using optimistic locking and full overwrite if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
            <param name="fullOverwrite">Will completely overwrite the database object in BigDB with the properties in this instance, instead of just sending the changed properties to the server.</param>
            <param name="successCallback">Callback when the save succeeds</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Save(System.Boolean,System.Boolean,PlayerIOClient.Callback,PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Persist the object to the database, using optimistic locking and full overwrite if specified</summary>
            <param name="useOptimisticLock">If true, the save will only be completed if the database object has not changed in BigDB since this instance was loaded.</param>
            <param name="fullOverwrite">Will completely overwrite the database object in BigDB with the properties in this instance, instead of just sending the changed properties to the server.</param>
            <param name="successCallback">Callback when the save succeeds</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the save.</param>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.#ctor">
            <summary>DatabaseObject constructor</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Clear">
            <summary>Removes all properties on this object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Remove(System.String)">
            <summary>Removes the value of the given property from this object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Contains(System.String)">
            <summary>Returns true if the given property exists on this object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.TryGetValue(System.String,System.Object@)">
            <summary>If the given property exists, this method returns true and the value as object in the out parameter. If it does not, this method return false</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetValue(System.String)">
            <summary>Get the given property as an object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetString(System.String)">
            <summary>Get the given string property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetString(System.String,System.String)">
            <summary>Get the given string property, falling back to the given default value if the string property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetInt(System.String)">
            <summary>Get the given int property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetInt(System.String,System.Int32)">
            <summary>Get the given int property, falling back to the given default value if the int property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetUInt(System.String)">
            <summary>Get the given uint property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetUInt(System.String,System.UInt32)">
            <summary>Get the given uint property, falling back to the given default value if the uint property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetLong(System.String)">
            <summary>Get the given long property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetLong(System.String,System.Int64)">
            <summary>Get the given long property, falling back to the given default value if the long property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetBool(System.String)">
            <summary>Get the given bool property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetBool(System.String,System.Boolean)">
            <summary>Get the given bool property, falling back to the given default value if the bool property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetFloat(System.String)">
            <summary>Get the given float property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetFloat(System.String,System.Single)">
            <summary>Get the given float property, falling back to the given default value if the float property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetDouble(System.String)">
            <summary>Get the given double property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetDouble(System.String,System.Double)">
            <summary>Get the given double property, falling back to the given default value if the double property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetBytes(System.String)">
            <summary>Get the given byte array property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetBytes(System.String,System.Byte[])">
            <summary>Get the given byte array property, falling back to the given default value if the byte array property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetDateTime(System.String)">
            <summary>Get the given datetime property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetDateTime(System.String,System.DateTime)">
            <summary>Get the given datetime property, falling back to the given default value if the datetime property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetObject(System.String)">
            <summary>Get the given object property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.GetArray(System.String)">
            <summary>Get the given array property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.String)">
            <summary>Set the given property to the given string value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Int32)">
            <summary>Set the given property to the given int value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.UInt32)">
            <summary>Set the given property to the given uint value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Int64)">
            <summary>Set the given property to the given long value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Boolean)">
            <summary>Set the given property to the given bool value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Single)">
            <summary>Set the given property to the given float value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Double)">
            <summary>Set the given property to the given double value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.Byte[])">
            <summary>Set the given property to the given byte array value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,System.DateTime)">
            <summary>Set the given property to the given datetime value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,PlayerIOClient.DatabaseObject)">
            <summary>Set the given property to the given object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseObject.Set(System.String,PlayerIOClient.DatabaseArray)">
            <summary>Set the given property to the given array</summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseObject.ExistsInDatabase">
            <summary>Returns true if the object has been persisted</summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseObject.Count">
            <summary>Returns the number of properties on this object</summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseObject.Item(System.String)">
            <summary>Get the given property as an object</summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseObject.Properties">
            <summary>Get the names of all properties on this object</summary>
        </member>
        <member name="T:PlayerIOClient.DatabaseArray">
            <summary>
            Represents an BigDB array of values that can be accessed by index.
            <para>DatabaseArray is very similar to the DatabaseObject class since it has methods for getting, setting, checking and removing values. But unlike DatabaseObject, this class also has methods for adding and inserting values, and there is no Save method, since these cannot be saved to a BigDB table, they always have to be a property of an object.</para>
            <para>If we for exameple have an object that can be visualized like this:</para>
            <code>
            'car54321' = {
            	Name: 'OldSpeedy',
            	LatestLapTimes: [
            		{
            			Time:'20:34',
            			Position:1
            		},
            		{
            			Time:'22:03',
            			Position:4
            		},
            		{
            			Time:'22:30',
            			Position:5
            		}
            	]
            }
            </code>
            <para>Then we would create it in BigDB like this:</para>
            <code>
            //Create new object
            DatabaseObject car = new DatabaseObject();
            car.Set("Name", "OldSpeedy");
            
            //Make laptimes
            DatabaseObject laptime1 = new DatabaseObject();
            laptime1.Set("Time", "20:34");
            laptime1.Set("Position", 1);
            DatabaseObject laptime2 = new DatabaseObject();
            laptime2.Set("Time", "22:03");
            laptime2.Set("Position", 4);
            DatabaseObject laptime3 = new DatabaseObject();
            laptime3.Set("Time", "22:30");
            laptime3.Set("Position", 5);
            
            //Make array and add laptimes
            DatabaseArray laptimes = new DatabaseArray();
            laptimes.Add(laptime1);
            laptimes.Add(laptime2);
            laptimes.Add(laptime3);
            
            //Add array to car object
            car.Set("LatestLapTimes", laptimes);
            
            //Save car to table "Cars" under key "car54321"
            PlayerIO.BigDB.CreateObject("Cars", "car54321", car, null);
            </code>
            
            <para>However, just like DatabaseObject, DatabaseArray also supports nested property names, and we can refer to values in the array with their index number. Using this, we can make the example object in an easier way, like this:</para>
            <code>
            DatabaseObject car = new DatabaseObject();
            car.Set("Name", "OldSpeedy");
            car.Set("LatestLapTimes", new DatabaseArray());
            car.Set("LatestLapTimes.0.Time", "20:34");
            car.Set("LatestLapTimes.0.Position", 1);
            car.Set("LatestLapTimes.1.Time", "22:03");
            car.Set("LatestLapTimes.1.Position", 4);
            car.Set("LatestLapTimes.2.Time", "22:30");
            car.Set("LatestLapTimes.2.Position", 5);
            </code>
            
            <para>Getting values works exactly like for DatabaseObject, and we can also use nested properties.</para>
            <code>
            PlayerIO.BigDB.Load("Cars", "car54321", delegate(DatabaseObject car) {
            	//Get position from first laptime
            	DatabaseArray laptimes = car.GetArray("LatestLapTimes");
            	DatabaseObject laptime = laptimes.GetObject(0);
            	int position = laptime.GetInt("Position");
            
            	//Get position from second laptime
            	int position2 = laptimes.GetInt("1.Position");
            	
            	//Or get position from third laptime directly
            	int position3 = car.GetInt("LatestLapTimes.2.Position");
            });
            </code>
            
            <para>In addition to getting and setting values, we can also add values to the end of the array, insert values in the middle of it, or remove values in the middle of it. Note that the arrays are sparse, this means that removing a value doesn't shift the indexes of the following values, and we can set any value beyond the last value of the array.</para>
            <code>
            DatabaseArray arr = new DatabaseArray();
            //We make an array like this: ['a', 'c']
            arr.Add("a");
            arr.Add("c");
            
            //Now it will look like this: ['a', 'c', 'd']
            arr.Add("d");
            
            //We insert a value where c is to get this: ['a', 'b', 'c', 'd']
            arr.Insert(1, "b");
            
            //If we then remove the third value we get this: ['a', 'b', null, 'd']
            arr.RemoveAt(2);
            
            //Finally, we set the sixth value and get: ['a', 'b', null, 'd', null, 'f']
            arr.Set(5, "f");
            </code>
            </summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.#ctor">
            <summary>DatabaseArray constructor</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Clear">
            <summary>Remove all values from this array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.RemoveAt(System.Int32)">
            <summary>Remove the value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Contains(System.Int32)">
            <summary>Returns true if a value exists at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetValue(System.Int32)">
            <summary>Get the value at the given index as an object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32)">
            <summary>Get the string value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.String)">
            <summary>Get the string value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetInt(System.Int32)">
            <summary>Get the int value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Int32)">
            <summary>Get the int value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetUInt(System.Int32)">
            <summary>Get the uint value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.UInt32)">
            <summary>Get the uint value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetLong(System.Int32)">
            <summary>Get the long value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Int64)">
            <summary>Get the long value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBool(System.Int32)">
            <summary>Get the bool value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Boolean)">
            <summary>Get the bool value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetFloat(System.Int32)">
            <summary>Get the float value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Single)">
            <summary>Get the float value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDouble(System.Int32)">
            <summary>Get the double value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Double)">
            <summary>Get the double value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBytes(System.Int32)">
            <summary>Get the byte array value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.Byte[])">
            <summary>Get the byte value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDateTime(System.Int32)">
            <summary>Get the datetime value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.Int32,System.DateTime)">
            <summary>Get the datetime value at the given index, falling back to the given default value if the value was at the index is null</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetObject(System.Int32)">
            <summary>Get the object at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetArray(System.Int32)">
            <summary>Get the array at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.String)">
            <summary>Set the value at the given index to the given string</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Int32)">
            <summary>Set the value at the given index to the given int</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.UInt32)">
            <summary>Set the value at the given index to the given uint</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Int64)">
            <summary>Set the value at the given index to the given long</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Boolean)">
            <summary>Set the value at the given index to the given bool</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Single)">
            <summary>Set the value at the given index to the given float</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Double)">
            <summary>Set the value at the given index to the given double</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.Byte[])">
            <summary>Set the value at the given index to the given byte array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,System.DateTime)">
            <summary>Set the value at the given index to the given datetime</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,PlayerIOClient.DatabaseObject)">
            <summary>Set the value at the given index to the given object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.Int32,PlayerIOClient.DatabaseArray)">
            <summary>Set the value at the given index to the given array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.String)">
            <summary>Insert the given string value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Int32)">
            <summary>Insert the given int value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.UInt32)">
            <summary>Insert the given uint value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Int64)">
            <summary>Insert the given long value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Boolean)">
            <summary>Insert the given bool value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Single)">
            <summary>Insert the given float value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Double)">
            <summary>Insert the given double value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.Byte[])">
            <summary>Insert the given byte array value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,System.DateTime)">
            <summary>Insert the given datetime value at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,PlayerIOClient.DatabaseObject)">
            <summary>Insert the given object at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Insert(System.Int32,PlayerIOClient.DatabaseArray)">
            <summary>Insert the given array at the given index</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.String)">
            <summary>Add the given string value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Int32)">
            <summary>Add the given int value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.UInt32)">
            <summary>Add the given uint value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Int64)">
            <summary>Add the given long value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Boolean)">
            <summary>Add the given bool value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Single)">
            <summary>Add the given float value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Double)">
            <summary>Add the given double value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.Byte[])">
            <summary>Add the given byte array value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(System.DateTime)">
            <summary>Add the given datetime value to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(PlayerIOClient.DatabaseObject)">
            <summary>Add the given object to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Add(PlayerIOClient.DatabaseArray)">
            <summary>Add the given array to the array</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Remove(System.String)">
            <summary>Removes the value of the given property from this object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Contains(System.String)">
            <summary>Returns true if the given property exists on this object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.TryGetValue(System.String,System.Object@)">
            <summary>If the given property exists, this method returns true and the value as object in the out parameter. If it does not, this method return false</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetValue(System.String)">
            <summary>Get the given property as an object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.String)">
            <summary>Get the given string property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetString(System.String,System.String)">
            <summary>Get the given string property, falling back to the given default value if the string property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetInt(System.String)">
            <summary>Get the given int property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetInt(System.String,System.Int32)">
            <summary>Get the given int property, falling back to the given default value if the int property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetUInt(System.String)">
            <summary>Get the given uint property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetUInt(System.String,System.UInt32)">
            <summary>Get the given uint property, falling back to the given default value if the uint property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetLong(System.String)">
            <summary>Get the given long property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetLong(System.String,System.Int64)">
            <summary>Get the given long property, falling back to the given default value if the long property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBool(System.String)">
            <summary>Get the given bool property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBool(System.String,System.Boolean)">
            <summary>Get the given bool property, falling back to the given default value if the bool property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetFloat(System.String)">
            <summary>Get the given float property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetFloat(System.String,System.Single)">
            <summary>Get the given float property, falling back to the given default value if the float property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDouble(System.String)">
            <summary>Get the given double property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDouble(System.String,System.Double)">
            <summary>Get the given double property, falling back to the given default value if the double property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBytes(System.String)">
            <summary>Get the given byte array property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetBytes(System.String,System.Byte[])">
            <summary>Get the given byte array property, falling back to the given default value if the byte array property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDateTime(System.String)">
            <summary>Get the given datetime property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetDateTime(System.String,System.DateTime)">
            <summary>Get the given datetime property, falling back to the given default value if the datetime property does not exist</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetObject(System.String)">
            <summary>Get the given object property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.GetArray(System.String)">
            <summary>Get the given array property</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.String)">
            <summary>Set the given property to the given string value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Int32)">
            <summary>Set the given property to the given int value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.UInt32)">
            <summary>Set the given property to the given uint value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Int64)">
            <summary>Set the given property to the given long value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Boolean)">
            <summary>Set the given property to the given bool value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Single)">
            <summary>Set the given property to the given float value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Double)">
            <summary>Set the given property to the given double value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.Byte[])">
            <summary>Set the given property to the given byte array value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,System.DateTime)">
            <summary>Set the given property to the given datetime value</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,PlayerIOClient.DatabaseObject)">
            <summary>Set the given property to the given object</summary>
        </member>
        <member name="M:PlayerIOClient.DatabaseArray.Set(System.String,PlayerIOClient.DatabaseArray)">
            <summary>Set the given property to the given array</summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseArray.Count">
            <summary>
            Returns the number of values in this array.
            If set to a smaller number than the current count, it will truncate the array.
            </summary>
        </member>
        <member name="P:PlayerIOClient.DatabaseArray.Item(System.Int32)">
            <summary>Get the value at the given index as an object</summary>
        </member>
        <member name="T:PlayerIOClient.ErrorLog">
            <summary>The Player.IO ErrorLog service</summary>
        </member>
        <member name="M:PlayerIOClient.ErrorLog.WriteError(System.String)">
            <summary>Write an entry to the game's error log. In development the errors are just written to the console, in production they're written to a database and browseable from the admin panel</summary>
            <param name="error">A short string describing the error without details. Example 'Unhandled exception'</param>
        </member>
        <member name="M:PlayerIOClient.ErrorLog.WriteError(System.String,System.Exception)">
            <summary>Write an entry to the game's error log. In development the error are just written to the console, in production they're written to a database and browseable from the admin panel</summary>
            <param name="error">A short string describing the error without details. Example 'Unhandled exception'</param>
            <param name="exception">The exception that caused the error</param>
        </member>
        <member name="M:PlayerIOClient.ErrorLog.WriteError(System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Write an entry to the games error log. In development the error are just written to the console, in production they're written to a database and browseable from the admin panel</summary>
            <param name="error">A short string describing the error without details. Example 'Object not set to instance of an object'</param>
            <param name="details">Describe the error in more detail if you have it. Example 'couldn't find the user 'bob' in the current game'</param>
            <param name="stacktrace">The stacktrace (if available) of the error</param>
            <param name="extraData">Any extra data you'd like to associate with the error log entry</param>
        </member>
        <member name="M:PlayerIOClient.Multiplayer.CreateRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Create an multiplayer room on the Player.IO infrastructure</summary>
            <param name="roomId">The id you wish to assign to your new room - You can use this to connect to the specific room later as long as it still exists</param>
            <param name="serverType">The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">Should the room be visible when listing rooms with GetRooms</param>
            <param name="roomData">The data to initialize the room with, this can be read with ListRooms and changed from the serverside</param>
            <returns>The id of the room that was created</returns>
        </member>
        <member name="M:PlayerIOClient.Multiplayer.JoinRoom(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Join a running multiplayer room</summary>
            <param name="roomId">The id of the room you wish to connect to</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <returns>A connection into the room</returns>
        </member>
        <member name="M:PlayerIOClient.Multiplayer.ListRooms(System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.Int32,System.Int32)">
            <summary>List the currently running multiplayer rooms</summary>
            <param name="serverType">The type of room you wish to list</param>
            <param name="searchCriteria">Only rooms with the same values in their roomdata will be returned</param>
            <param name="resultLimit">The maximum amount of rooms you want to receive. Use 0 for 'as many as possible'.</param>
            <param name="resultOffset">The offset into the list you wish</param>
            <returns>A list of rooms matching the search criteria</returns>
        </member>
        <member name="M:PlayerIOClient.Multiplayer.CreateJoinRoom(System.String,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Creates a multiplayer room (if it does not exist already) and joins it.</summary>
            <param name="roomId">The id of the room you wish to create/join</param>
            <param name="serverType">If the room dosn't exist: The name of the server code you wish to run the room as. This should be one of the names from the Multiplayer overview section in the Player.IO admin panel. A servertype of 'bounce' is always available.</param>
            <param name="visible">If the room dosn't exist: Should the room be visible when listing rooms with GetRooms upon creation</param>
            <param name="roomData">If the room dosn't exist: The data to initialize the room with upon creation</param>
            <param name="joinData">Data to send to the room with additional information about the join </param>
            <returns>A connection into the room that was created</returns>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.SimpleConnect(System.String,System.String,System.String)">
            <summary>Authenticates a user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="usernameOrEmail">The username or email of the user you wish to authenticate.</param>
            <param name="password">The password of the user you wish to authenticate.</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.SimpleGetCaptcha(System.String,System.Int32,System.Int32)">
            <summary>Creates a Captcha image and key, to be used for registrations where the added security of Captcha is required..</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="width">The width of the Captcha image.</param>
            <param name="height">The height of the Captcha image.</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.SimpleRegister(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Registers a new user in the simple user db and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel.</param>
            <param name="username">The username of the new user.</param>
            <param name="password">The password of the new user.</param>
            <param name="email">The email of the new user. (optional)</param>
            <param name="captchaKey">(only if captcha is required) The key of the Captcha image used to get the user to write in the Captcha value</param>
            <param name="captchaValue">(only if captcha is required) The string the user entered in response to the captcha image</param>
            <param name="extraData">Any extra data that you wish to store with the user such as gender, birthdate, etc. (optional)</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.SimpleRecoverPassword(System.String,System.String)">
            <summary>Initiates the password recovery process for a user. The user must have supplied an email address during registration.</summary>
            <param name="gameId">The game id of the game the user is registered in.</param>
            <param name="usernameOrEmail">The username or email address of the user that wishes to recover his password.</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.FacebookConnect(System.String,System.String,System.String)">
            <summary>Authenticates a Facebook user and session and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="uid">The Facebook uid of the user you wish to authenticate.</param>
            <param name="sessionKey">The Facebook session key of the user's session.</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.FacebookOAuthConnect(System.String,System.String)">
            <summary>Authenticates a Facebook user using a Facebook access_token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="access_token">The Facebook access_token for the user.</param>
        </member>
        <member name="M:PlayerIOClient.QuickConnect.KongregateConnect(System.String,System.String,System.String)">
            <summary>Authenticates a Kongregate user and returns a connection token.</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="userId">The Kongregate user id of the user you wish to authenticate.</param>
            <param name="gameAuthToken">The Kongregate game auth token of the user's session.</param>
        </member>
        <member name="T:PlayerIOClient.Web">
            <summary>
            An easy way to communicate with servers and services outside 
            Player.IO via http requests
            </summary>
        </member>
        <member name="M:PlayerIOClient.Web.Get(System.String)">
            <summary>Perform a HTTP Get request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <returns>The http response returned from the remote server</returns>
        </member>
        <member name="M:PlayerIOClient.Web.Get(System.String,PlayerIOClient.Callback{PlayerIOClient.HttpResponse})">
            <summary>Perform a HTTP Get request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <param name="successCallback">Callback with a stream of the returned page</param>
        </member>
        <member name="M:PlayerIOClient.Web.Get(System.String,PlayerIOClient.Callback{PlayerIOClient.HttpResponse},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Perform a HTTP Get request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <param name="successCallback">Callback with a stream of the returned page</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the request.</param>
        </member>
        <member name="M:PlayerIOClient.Web.Post(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>Perform a HTTP Get request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <param name="post">The values to post to the given url</param>
            <returns>The http response returned from the remote server</returns>
        </member>
        <member name="M:PlayerIOClient.Web.Post(System.String,System.Collections.Generic.Dictionary{System.String,System.String},PlayerIOClient.Callback{PlayerIOClient.HttpResponse})">
            <summary>Perform a HTTP Post request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <param name="post">The values to post to the given url</param>
            <param name="successCallback">Callback with a stream of the returned page</param>
        </member>
        <member name="M:PlayerIOClient.Web.Post(System.String,System.Collections.Generic.Dictionary{System.String,System.String},PlayerIOClient.Callback{PlayerIOClient.HttpResponse},PlayerIOClient.Callback{PlayerIOClient.PlayerIOError})">
            <summary>Perform a HTTP Post request.</summary>
            <param name="url">The url to request, including querystring arguments (if any)</param>
            <param name="post">The values to post to the given url</param>
            <param name="successCallback">Callback with a stream of the returned page</param>
            <param name="errorCallback">Callback that will be called instead of successCallback if an error occurs during the request.</param>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnsupportedMethod">
            <summery>The method requested is not supported</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.GeneralError">
            <summery>A general error occured</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InternalError">
            <summery>An unexpected error occured inside the Player.IO webservice. Please try again.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.AccessDenied">
            <summery>Access is denied</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidMessageFormat">
            <summery>The message is malformatted</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.MissingValue">
            <summery>A value is missing</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.GameRequired">
            <summery>A game is required to do this action</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.ExternalError">
            <summery>An error occurred while contacting an external service</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.ArgumentOutOfRange">
            <summery>The given argument value is outside the range of allowed values.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.GameDisabled">
            <summery>The game has been disabled, most likely because of missing payment.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownGame">
            <summery>The game requested is not known by the server</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownConnection">
            <summery>The connection requested is not known by the server</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidAuth">
            <summery>The auth given is invalid or malformatted</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.NoAvailableServers">
            <summery>There are no servers available in the cluster, please try again later (never occurs)</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.RoomDataTooLarge">
            <summery>The room data for the room was over the allowed size limit</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.RoomAlreadyExists">
            <summery>You are unable to create room because there is already a room with the specified id</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownServerType">
            <summery>The game you're connected to does not have a server type with the specified name</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownRoom">
            <summery>There is no room running with that id</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.MissingRoomId">
            <summery>You can't join the room when the RoomID is null or the empty string</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.RoomIsFull">
            <summery>The room already has the maxmium amount of users in it.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.NotASearchColumn">
            <summery>The key you specified is not set as searchable. You can change the searchable keys in the admin panel for the server type</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.QuickConnectMethodNotEnabled">
            <summery>The QuickConnect method (simple, facebook, kongregate...) is not enabled for the game. You can enable the various methods in the admin panel for the game</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownUser">
            <summery>The user is unknown</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidPassword">
            <summery>The password supplied is incorrect</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidRegistrationData">
            <summery>The supplied data is incorrect</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidBigDBKey">
            <summery>The key given for the BigDB object is not a valid BigDB key. BigDB keys must be between 1 and 50 word characters (no spaces).</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.BigDBObjectTooLarge">
            <summery>The object exceeds the maximum allowed size for BigDB objects.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.BigDBObjectDoesNotExist">
            <summery>Could not locate the database object.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownTable">
            <summery>The specified table does not exist.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.UnknownIndex">
            <summery>The specified index does not exist.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.InvalidIndexValue">
            <summery>The value given for the index, does not match the expeceded type.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.NotObjectCreator">
            <summery>The operation was aborted because the user attempting the operation was not the original creator of the object accessed.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.KeyAlreadyUsed">
            <summery>The key is in use by another database object</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.StaleVersion">
            <summery>BigDB object could not be saved using optimistic locks as it's out of date.</summery>
        </member>
        <member name="F:PlayerIOClient.ErrorCode.CircularReference">
            <summery>Cannot create circular references inside database objects</summery>
        </member>
        <member name="T:PlayerIOClient.Message">
            <summary>
            Represents a message sent between client and server.
            
            <para>A message consists of a string type, and a 
            payload of zero or more typed parameters.</para>
            
            <para>For example here we create a simple message that the server broadcasts to connected players indicating that a round is starting:</para>
            <code>
            	// message of type start with no payload
            	Message m = Message.Create("start"); 
            	 
            	// send the message to all connected players
            	Broadcast(m);
            </code>
            <para>Usually, it's much easier to simply use the convenience methods:</para>
            <code>
            public override void UserJoined(BasePlayer player) {
            	// send the player a message of type "mapinfo" with two pieces
            	// of data payload: the mapnam (string) and number of players (int)
            	player.Send("mapinfo", "fields-of-glory", PlayerCount );
            
            	// broadcast to all connected players a message with type "userjoined"
            	// and a single payload of just the player id (uint)
            	Broadcast("userjoined", player.Id);
            }
            </code>
            <para>You can also build up messages as you go, if you don't know the exact payload untill runtime.</para>
            <para>In this example we send out the ConnectIds of all connected players to every new player that joins the room.</para>
            <code>
            public override void UserJoined(BasePlayer player) {
            	// create a new message of type join
            	Message joinMessage = Message.Create("join"); 
            
            	// add all the currently connected userids to the message
            	foreach(var p in Players) {
            		joinMessage.Add(p.ConnectUserId);
            	}
            
            	// send the message to the player who joined
            	player.Send(joinMessage);
            }
            </code>
            </summary>
        </member>
        <member name="M:PlayerIOClient.Message.Create(System.String,System.Object[])">
            <summary>Create a new Message</summary>
            <param name="type">The type of message to create.</param>
            <param name="parameters">A variable list of the data to add to the message.</param>
            <returns></returns>
        </member>
        <member name="M:PlayerIOClient.Message.GetString(System.UInt32)">
            <summary>Gets the string at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetByteArray(System.UInt32)">
            <summary>Gets the byte[] at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetBoolean(System.UInt32)">
            <summary>Gets the bool at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetDouble(System.UInt32)">
            <summary>Gets the double at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetFloat(System.UInt32)">
            <summary>Gets the float at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetInteger(System.UInt32)">
            <summary>Gets the int at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetInt(System.UInt32)">
            <summary>Gets the int at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetUInt(System.UInt32)">
            <summary>Gets the uint at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetUnsignedInteger(System.UInt32)">
            <summary>Gets the uint at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetLong(System.UInt32)">
            <summary>Gets the long at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetULong(System.UInt32)">
            <summary>Gets the ulong at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.GetUnsignedLong(System.UInt32)">
            <summary>Gets the ulong at the given index</summary><param name="index">The index to find the entry in</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.String)">
            <summary>Add a string to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Int32)">
            <summary>Add a int to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.UInt32)">
            <summary>Add a uint to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Int64)">
            <summary>Add a long to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.UInt64)">
            <summary>Add a ulong to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Byte[])">
            <summary>Add a byte[] to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Single)">
            <summary>Add a float to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Double)">
            <summary>Add a double to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Boolean)">
            <summary>Add a bool to the message payload </summary><param name="value">the value to add</param>
        </member>
        <member name="M:PlayerIOClient.Message.Add(System.Object[])">
            <summary>
            Add multiple pieces of data to the message in one go.
            </summary>
            <example>
            Adding a string, a number and two boolean values to the message.
            <code>somemessage.Add("a string", 1234, true, false)</code>
            </example>
            <param name="parameters">The data to add to the message</param>
        </member>
        <member name="P:PlayerIOClient.Message.Type">
            <summary>The type of the current message</summary>
        </member>
        <member name="P:PlayerIOClient.Message.Count">
            <summary>The number of data entries in the message, excluding the type.</summary>
        </member>
        <member name="P:PlayerIOClient.Message.Item(System.UInt32)">
            <summary>Get the data stored in the mesage at the given index</summary>
        </member>
        <member name="P:PlayerIOClient.ServerEndpoint.Address">
            <summary>The address/hostname of the server</summary>
        </member>
        <member name="P:PlayerIOClient.ServerEndpoint.Port">
            <summary>The port of the server</summary>
        </member>
        <member name="P:PlayerIOClient.RoomInfo.Id">
            <summary>The id of the room</summary>
        </member>
        <member name="P:PlayerIOClient.RoomInfo.ServerType">
            <summary>The name of the server type the room is running</summary>
        </member>
        <member name="P:PlayerIOClient.RoomInfo.OnlineUsers">
            <summary>How many users are currently in the room</summary>
        </member>
        <member name="P:PlayerIOClient.RoomInfo.RoomData">
            <summary>The current room data for the room</summary>
        </member>
        <member name="P:PlayerIOClient.PlayerIORegistrationError.UsernameError">
            <summary>The error for the username field, if any</summary>
        </member>
        <member name="P:PlayerIOClient.PlayerIORegistrationError.PasswordError">
            <summary>The error for the password field, if any</summary>
        </member>
        <member name="P:PlayerIOClient.PlayerIORegistrationError.EmailError">
            <summary>The error for the email field, if any</summary>
        </member>
        <member name="P:PlayerIOClient.PlayerIORegistrationError.CaptchaError">
            <summary>The error for the captcha field, if any</summary>
        </member>
        <member name="P:PlayerIOClient.SimpleGetCaptchaOutput.CaptchaKey">
            <summary>The key for this captcha image. This value must be kept and sent to the simpleRegister() method along with the string from the user</summary>
        </member>
        <member name="P:PlayerIOClient.SimpleGetCaptchaOutput.CaptchaImageUrl">
            <summary>An url for the captcha image. You must show the image to the user, and ask what text is shown in the image.</summary>
        </member>
        <member name="T:PlayerIOClient.HttpResponse">
            <summary>
            The response from a HTTP Get or Post request
            </summary>
        </member>
        <member name="P:PlayerIOClient.HttpResponse.StatusCode">
            <summary>The status code returned from the remote web server</summary>
        </member>
        <member name="P:PlayerIOClient.HttpResponse.ResponseStream">
            <summary>A stream with the body of the http response</summary>
        </member>
        <member name="P:PlayerIOClient.HttpResponse.Text">
            <summary>The response stream read as an UTF8 string</summary>
        </member>
        <member name="T:PlayerIOClient.PlayerIO">
            <summary>
            Entry class for the initial connection to Player.IO
            <para>Here is an example of using the class to connect to Player.IO</para>
            <code>
            //Connect to Player.IO
            var client = PlayerIO.Connect(
            	"[Enter your game id here]",
            	"public",				
            	"user-id",			
            	null			
            );
            </code>
            </summary>
        </member>
        <member name="M:PlayerIOClient.PlayerIO.CalcAuth(System.String,System.String)">
            <summary>Calculate an auth hash for use in the Connect method</summary>
            <param name="userId">The userid to use when generating the hash</param>
            <param name="sharedSecret">The shared secret to use when generating the hash. This must be the same value as the one given to a connection in the admin panel.</param>
            <returns>The generated auth hash</returns>
        </member>
        <member name="M:PlayerIOClient.PlayerIO.Connect(System.String,System.String,System.String,System.String)">
            <summary>Connects to Player.IO using as the given user</summary>
            <param name="gameId">The game id of the game you wish to connect to. This value can be found in the admin panel</param>
            <param name="connectionId">The id of the connection, as given in the settings section of the admin panel. 'public' should be used as the default</param>
            <param name="userId">The id of the user connecting. This can be any string you like.</param>
            <param name="auth">If the connection identified by ConnectionIdentifier only accepts authenticated requests, the auth value generated based on UserId is added here. You can generate an auth value using the CalcAuth() method.</param>
            <returns>A UserClient object from which Player.IO can be accessed.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.AsyncUtility.RunAsync``1(PlayerIOClient.Internal.AsyncBegin{``0},PlayerIOClient.Internal.AsyncEnd{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>Simplified calling convention for asynchronous Begin/End operations.</summary>
            <typeparam name="T">The type of data returned by the async operation.</typeparam>
            <param name="begin">The start (Begin*) of the async operation.</param>
            <param name="end">The end (End*) of the async operation.</param>
            <param name="callback">The operation to perform once the operation has completed and a value received.</param>
            <param name="exceptionHandler">Callback to invoke when an excetption is thrown during the async operation.</param>
        </member>
        <member name="T:PlayerIOClient.Internal.AsyncBegin`1">
            <summary>Defines the start of a Begin/End async operation pair.</summary>
            <typeparam name="T">The type of value returned by the async operation.</typeparam>
            <param name="operation">The operation to be performed.</param>
            <param name="state">User-state to be passed to the operation.</param>
            <returns>A token to the async operation.</returns>
        </member>
        <member name="T:PlayerIOClient.Internal.AsyncEnd`1">
            <summary>Defines the completion callback of a Begin/End async operation pair.</summary>
            <typeparam name="T">The type of value returned by the async operation.</typeparam>
            <param name="operation">The async operation token.</param>
            <returns>The final value of the async operation.</returns>
        </member>
        <member name="T:PlayerIOClient.Internal.BufferExtension">
            <summary>
            Provides a simple buffer-based implementation of an <see cref="T:PlayerIOClient.Internal.IExtension">extension</see> object.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.IExtension">
            <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtension.BeginAppend">
            <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
            <returns>A new stream suitable for storing data.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
            <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
            <param name="stream">The stream originally obtained by BeginAppend.</param>
            <param name="commit">True if the append operation completed successfully.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtension.BeginQuery">
            <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
            <returns>A prepared stream of the unexpected fields.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtension.EndQuery(System.IO.Stream)">
            <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
            <param name="stream">The stream originally obtained by BeginQuery.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtension.GetLength">
            <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
            <returns>The length of the binary stream representing unexpected data.</returns>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoBeforeSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoAfterSerializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoBeforeDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoAfterDeserializationAttribute">
            <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
        </member>
        <member name="T:PlayerIOClient.Internal.DataFormat">
            <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.DataFormat.Default">
            <summary>
            Uses the default encoding for the data-type.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.DataFormat.ZigZag">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.DataFormat.TwosComplement">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.DataFormat.FixedSize">
            <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.DataFormat.Group">
            <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.AsyncResult">
            <summary>
            Represents the function to obtain the return value from an asynchronouse operation;
            comparable to Func&lt;object&gt;.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.Getter`2">
            <summary>
            Returns the required value from an instance; comparable to Func&lt;TEntity,TValue&gt;
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.Setter`2">
            <summary>
            Assigns the required value to an instance; comparable to Action&lt;TEntity,TValue&gt;.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.Extensible">
            <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
            <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
            <seealso cref="T:PlayerIOClient.Internal.IExtensible"/>
        </member>
        <member name="T:PlayerIOClient.Internal.IExtensible">
            <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:PlayerIOClient.Internal.IExtension">extensions</see>.
            </summary>
            <remarks>Can be implemented by deriving from <see cref="T:PlayerIOClient.Internal.Extensible"/>.</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.IExtensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:PlayerIOClient.Internal.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetExtensionObject(System.Boolean)">
            <summary>
            Retrieves the <see cref="T:PlayerIOClient.Internal.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetExtensionObject(PlayerIOClient.Internal.IExtension@,System.Boolean)">
            <summary>
            Provides a simple, default implementation for <see cref="T:PlayerIOClient.Internal.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:PlayerIOClient.Internal.IExtensible"/>.
            </summary>
            <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
            <param name="extensionObject">The extension field to check (and possibly update).</param>
            <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
            <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.AppendValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The type of the value to append.</typeparam>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.AppendValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat,``0)">
            <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
            <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="format">The data-format to use when encoding the value.</param>
            <param name="instance">The extensible object to append the value to.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="value">The value to append.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetValue``1(PlayerIOClient.Internal.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>The effective value of the field, or the default value if not found.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.TryGetValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.TryGetValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.TryGetValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat,System.Boolean,``0@)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="value">The effective value of the field, or the default value if not found.</param>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
            <returns>True if data for the field was present, false otherwise.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetValues``1(PlayerIOClient.Internal.IExtensible,System.Int32)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Extensible.GetValues``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat)">
            <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
            <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
            <typeparam name="TValue">The data-type of the field.</typeparam>
            <param name="instance">The extensible object to obtain the value from.</param>
            <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
            <param name="format">The data-format to use when decoding the value.</param>
            <returns>An enumerator that yields each occurrence of the field.</returns>
        </member>
        <member name="T:PlayerIOClient.Internal.ExtensibleUtil">
            <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ExtensibleUtil.GetExtendedValues``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ExtensibleUtil.GetExtendedValuesTyped``2(``0,System.Int32,PlayerIOClient.Internal.DataFormat,System.Boolean,System.Boolean)">
            <summary>
            Reads the given value(s) from the instance's stream; the serializer
            is inferred from TValue and format. For singletons, each occurrence
            is merged [only applies for sub-objects], and the composed
            value if yielded once; otherwise ("repeated") each occurrence
            is yielded separately.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.ExtensibleUtil.AppendExtendValue``1(PlayerIOClient.Internal.IExtensible,System.Int32,PlayerIOClient.Internal.DataFormat,System.Object)">
            <summary>
            All this does is call AppendExtendValueTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ExtensibleUtil.AppendExtendValueTyped``2(``0,System.Int32,PlayerIOClient.Internal.DataFormat,``1)">
            <summary>
            Stores the given value into the instance's stream; the serializer
            is inferred from TValue and format.
            </summary>
            <remarks>Needs to be public to be callable thru reflection in Silverlight</remarks>
        </member>
        <member name="T:PlayerIOClient.Internal.Serializer">
            <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. 
            </summary>
            <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
        </member>
        <member name="F:PlayerIOClient.Internal.Serializer.ListItemTag">
            <summary>
            The implicit tag used when serializing lists and other enumerable data.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.TryGetTag(System.Reflection.MemberInfo,System.Int32@,System.String@,PlayerIOClient.Internal.DataFormat@,PlayerIOClient.Internal.MemberSerializationOptions@)">
            <summary>
            Supports various different property metadata patterns:
            [ProtoMember] is the most specific, allowing the data-format to be set.
            [DataMember], [XmlElement] are supported for compatibility.
            In any event, there must be a unique positive Tag/Order.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.DeserializeItems``1(System.IO.Stream,PlayerIOClient.Internal.PrefixStyle,System.Int32)">
            <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:PlayerIOClient.Internal.Serializer.ListItemTag"/> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
            <typeparam name="T">The type of object to deserialize.</typeparam>
            <param name="source">The binary stream containing the serialized records.</param>
            <param name="style">The prefix style used in the data.</param>
            <param name="tag">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
            <returns>The sequence of deserialized objects.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,PlayerIOClient.Internal.PrefixStyle)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,PlayerIOClient.Internal.PrefixStyle,System.Int32)">
            <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
            <typeparam name="T">The type to be created.</typeparam>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="tag">The expected tag of the item (only used with base-128 prefix style).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.TryReadLengthPrefix(System.IO.Stream,PlayerIOClient.Internal.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="source">The stream containing the data to investigate for a length.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,PlayerIOClient.Internal.PrefixStyle,System.Int32@)">
            <summary>Indicates the number of bytes expected for the next message.</summary>
            <param name="buffer">The buffer containing the data to investigate for a length.</param>
            <param name="index">The offset of the first byte to read from the buffer.</param>
            <param name="count">The number of bytes to read from the buffer.</param>
            <param name="style">The algorithm used to encode the length.</param>
            <param name="length">The length of the message, if it could be identified.</param>
            <returns>True if a length could be obtained, false otherwise.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.Merge``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,PlayerIOClient.Internal.PrefixStyle)">
            <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (can be null).</param>
            <param name="source">The binary stream to apply to the instance (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,PlayerIOClient.Internal.PrefixStyle)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,PlayerIOClient.Internal.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="tag">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
            <typeparam name="T">The type being serialized.</typeparam>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="writer">The destination XmlWriter to write to.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.Merge``1(System.Xml.XmlReader,``0)">
            <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
            <typeparam name="T">The type being merged.</typeparam>
            <param name="instance">The existing instance to be modified (cannot be null).</param>
            <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.DeepClone``1(``0)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
            <typeparam name="T">The type being cloned.</typeparam>
            <param name="instance">The existing instance to be cloned.</param>
            <returns>A new copy, cloned from the supplied instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.ChangeType``2(``0)">
            <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
            <remarks>No assumption of compatibility is made between the types.</remarks>
            <typeparam name="TOldType">The type of the object being copied.</typeparam>
            <typeparam name="TNewType">The type of the new object to be created.</typeparam>
            <param name="instance">The existing instance to use as a template.</param>
            <returns>A new instane of type TNewType, with the data from TOldType.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.ChangeType``2(``0,PlayerIOClient.Internal.SerializationContext)">
            <summary>
            As per the public ChangeType, but allows for workspace-sharing to reduce buffer overhead.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.GetProto``1">
            <summary>
            Suggest a .proto definition for the given type
            </summary>
            <typeparam name="T">The type to generate a .proto definition for</typeparam>
            <returns>The .proto definition as a string</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.PrepareSerializer``1">
            <summary>
            Ensures that the serialization algorithm has been prepared for
            the given type; this can be useful in highly threaded code to
            ensure that all types are ready ahead of time, avoiding deadlock
            scenarios.
            </summary>
            <typeparam name="T">The object type to prepare.</typeparam>
        </member>
        <member name="T:PlayerIOClient.Internal.Serializer.GlobalOptions">
            <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.Serializer.NonGeneric">
            <summary>
            Provides non-generic, reflection-based access to Serializer functionality
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,PlayerIOClient.Internal.PrefixStyle,System.Int32)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="style">How to encode the length prefix.</param>
            <param name="destination">The destination stream to write to.</param>
            <param name="tag">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
            <param name="instance">The existing instance to be serialized (cannot be null).</param>
            <param name="destination">The destination stream to write to.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,PlayerIOClient.Internal.PrefixStyle,PlayerIOClient.Internal.Getter{System.Int32,System.Type},System.Object@)">
            <summary>
            Deserialize object of unknown types from in input stream.
            </summary>
            <param name="source">The input stream.</param>
            <param name="style">The prefix style used to encode the lengths.</param>
            <param name="typeReader">The caller must provide a mechanism to resolve a Type from
            the tags encountered in the stream. If the delegate returns null, then the instance
            is skipped - otherwise, the object is deserialized according to type.</param>
            <param name="item">The deserialized instance, or null if the stream terminated.</param>
            <returns>True if an object was idenfified; false if the stream terminated. Note
            that unexpected types are skipped.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
            <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
            <param name="type">The type to be created.</param>
            <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
            <returns>A new, initialized instance.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.Serializer.NonGeneric.DeepClone(System.Object)">
            <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
            <param name="instance">The existing instance to be cloned.</param>
            <returns>A new copy, cloned from the supplied instance.</returns>
        </member>
        <member name="T:PlayerIOClient.Internal.ImplicitFields">
            <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.ImplicitFields.None">
            <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.ImplicitFields.AllPublic">
            <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.ImplicitFields.AllFields">
            <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ObjectFactory`1">
            <summary>
            Abstract object factory, used to negate the need for a ": new()" generic constraint
            on Serializer-of-T.
            </summary>
            <typeparam name="T">The type of object to be created.</typeparam>
        </member>
        <member name="T:PlayerIOClient.Internal.PrefixStyle">
            <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.PrefixStyle.None">
            <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.PrefixStyle.Base128">
            <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.PrefixStyle.Fixed32">
            <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.PropertyEnum`2">
            <summary>
            Property implemenation that handles enum values.
            </summary>
            <remarks>All enum wire-values must be in the Int32 range.</remarks>
        </member>
        <member name="T:PlayerIOClient.Internal.PropertyFactory">
            <summary>
            Utility class for creating/initializing protobuf-net property
            wrappers.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.PropertyFactory.GetPassThru``1">
            <summary>
            Returns a Getter&lt;T,T&gt; delegate that simply returns
            the original value. This allows code re-use between
            different implementations.
            </summary>
            <remarks>Originally an anonymous method was used, but
            this proved problematic with the Mono 2.0 compiler.</remarks>
        </member>
        <member name="M:PlayerIOClient.Internal.PropertyFactory.CreatePassThru``1(System.Int32,PlayerIOClient.Internal.DataFormat@)">
            <summary>
            Create a simple Property that can be used standalone
            to encode/decode values for the given type.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.PropertyFactory.Create``1(System.Reflection.MemberInfo)">
            <summary>
            Create a Property based around a class
            member (PropertyInfo/FieldInfo).
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.PropertyFactory.CreateProperty``1(System.Type,PlayerIOClient.Internal.DataFormat@,PlayerIOClient.Internal.MemberSerializationOptions)">
            <summary>
            Responsible for deciding how to encode/decode a given data-type; maybe
            not the most elegant solution, but it is simple and quick.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.PropertyFactory.PassThruCache`1">
            <summary>
            Stores, per T, a pass-thru Getter&lt;T,T&gt; delegate.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.PropertyMessageGroup`4">
            <summary>
            Serializes an entity using group (delimited) syntax.
            The high number of type arguments is requird to support ancestral serialization;
            there are 2 use-cases:
              direct: for example, a property (base is the highest contract ancestor; prop = actual = the property-type)
              descendent: used internally to cascade inheritance; prop = base = the parent type, actual = the child type
            </summary>
            <typeparam name="TSource">The type declaring the member</typeparam>
            <typeparam name="TProperty">The defined member-type for accessing data</typeparam>
            <typeparam name="TEntityBase">The base-type to use when verifying / instantiating sub-type instances</typeparam>
            <typeparam name="TEntityActual">The type to use for serialization purposes</typeparam>
        </member>
        <member name="T:PlayerIOClient.Internal.PropertyMessageString`4">
            <summary>
            Serializes an entity using string (length-prefixed) syntax.
            The high number of type arguments is requird to support ancestral serialization;
            there are 2 use-cases:
              direct: for example, a property (base is the highest contract ancestor; prop = actual = the property-type)
              descendent: used internally to cascade inheritance; prop = base = the parent type, actual = the child type
            </summary>
            <typeparam name="TSource">The type declaring the member</typeparam>
            <typeparam name="TProperty">The defined member-type for accessing data</typeparam>
            <typeparam name="TEntityBase">The base-type to use when verifying / instantiating sub-type instances</typeparam>
            <typeparam name="TEntityActual">The type to use for serialization purposes</typeparam>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoContractAttribute">
            <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoContractAttribute.Name">
            <summary>
            Gets or sets the defined name of the type.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoContractAttribute.ImplicitFirstTag">
            <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoContractAttribute.ImplicitFields">
            <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoEnumAttribute">
            <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoEnumAttribute.HasValue">
            <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
            <returns>true if a specific value is set</returns>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoEnumAttribute.Value">
            <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoEnumAttribute.Name">
            <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoException">
            <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoException.#ctor">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoException.#ctor(System.String)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoException.#ctor(System.String,System.Exception)">
            <summary>Creates a new ProtoException instance.</summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoPartialIgnoreAttribute">
            <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoPartialIgnoreAttribute.#ctor(System.String)">
            <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
            <param name="memberName">Specifies the member to be ignored.</param>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoPartialIgnoreAttribute.MemberName">
            <summary>
            The name of the member to be ignored.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoIncludeAttribute">
            <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownType">The additional type to serialize/deserialize.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
            <param name="tag">The unique index (within the type) that will identify this data.</param>
            <param name="knownTypeName">The additional type to serialize/deserialize.</param>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoIncludeAttribute.Tag">
            <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoIncludeAttribute.KnownTypeName">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoIncludeAttribute.KnownType">
            <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoIncludeAttribute.DataFormat">
            <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoMemberAttribute.#ctor(System.Int32)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoMemberAttribute.Name">
            <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoMemberAttribute.DataFormat">
            <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoMemberAttribute.Tag">
            <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoMemberAttribute.IsRequired">
            <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoMemberAttribute.Options">
            <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.MemberSerializationOptions">
            <summary>
            Additional (optional) settings that control serialization of members
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.MemberSerializationOptions.None">
            <summary>
            Default; no additional options
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.MemberSerializationOptions.Packed">
            <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.MemberSerializationOptions.Required">
            <summary>
            Indicates that the given item is required
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.ProtoPartialMemberAttribute">
            <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
            <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
            <param name="memberName">Specifies the member to be serialized.</param>
        </member>
        <member name="P:PlayerIOClient.Internal.ProtoPartialMemberAttribute.MemberName">
            <summary>
            The name of the member to be serialized.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.StreamState.Normal">
            <summary>
            Indicates that an EOF is not anticipated, and so will throw an exception.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.StreamState.EofExpected">
            <summary>
            Indicates that an EOF is acceptable at the current time and will
            not throw an exception.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.StreamState.Peeked">
            <summary>
            Indicates that we have previously obtained a field value from
            the stream that should be consumed next.
            </summary>
        </member>
        <member name="F:PlayerIOClient.Internal.StreamState.Eof">
            <summary>
            Indicates that we have found the end of the stream; this is **only**
            used to commicate to "Try", and should not persist.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Push(System.Object)">
            <summary>
            Allows for recursion detection by capturing
            the call tree; this only takes effect after
            an initial threshold call-depth is reached.
            If the object is already in the call-tree,
            an exception is thrown.
            </summary>
            <param name="obj">The item being processed (start).</param>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Push">
            <summary>
            Only used during debugging for the text nest-level
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Pop">
            <summary>
            Only used during debugging for the text nest-level
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Pop(System.Object)">
            <summary>
            Removes an object from the call-tree.
            </summary>
            <remarks>The object is not checked for validity (peformance);
            ensure that objects are pushed/popped correctly.</remarks>
            <param name="obj">The item being processed (end).</param>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.DecodeUInt32Fixed(System.IO.Stream)">
            <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.TryDecodeUInt32Fixed(System.IO.Stream,System.UInt32@)">
            <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.DecodeUInt32(System.IO.Stream)">
            <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.SkipStringData(System.IO.Stream)">
            <summary>
            Jump a block of data using a base-128 length prefix.
            </summary>
            <param name="source">The input stream.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.TryDecodeUInt32(System.IO.Stream,System.UInt32@)">
            <summary>
            Slow (unbuffered) read from a stream; used to avoid issues
            with buffers when performing network IO.
            </summary>
            <returns>True if there is data in the stream and a value can be obtained;
            False if there is no data in the stream; note that an exception is still
            thrown if the data is invalid.</returns>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Fill(System.Int32,System.Boolean)">
            <summary>
            Fills the IO buffer if there is not enough data buffered to complete the current operation.
            </summary>
            <param name="required">The maximum number of bytes required by the current operation.</param>
            <param name="demand">Should an exception be thrown if the data is not available?</param>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Fill">
            <summary>
            Fills the IO buffer, moving any un-consumed data to the beginning of the cache.
            </summary>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Flush(System.Int32)">
            <summary>
            Flushes the IO buffer if there is not enough space to complete the current operation.
            </summary>
            <param name="spaceRequired">The maximum number of bytes required by the current operation.</param>
        </member>
        <member name="M:PlayerIOClient.Internal.SerializationContext.Flush">
            <summary>
            Flushes the IO buffer, writing any cached data to the underlying stream and resetting the cache.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.SubStream">
            <summary>
            Describes a Stream that wraps an underlying stream but
            which limits the length. This is used for processing
            length-prefied messages (string wire-type) so that no
            complex code is required to manage the end of each
            object.
            </summary>
        </member>
        <member name="T:PlayerIOClient.Internal.UnknownType">
            <summary>
            The (non-extensible) UnknownType is used when deserializing
            unexpected groups.
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.Variant">
            <summary>
            Base-128 variant-length encoding
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.Fixed64">
            <summary>
            Fixed-length 8-byte encoding
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.String">
            <summary>
            Length-variant-prefixed encoding
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.StartGroup">
            <summary>
            Indicates the start of a group
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.EndGroup">
            <summary>
            Indicates the end of a group
            </summary>
        </member>
        <member name="F:PlayerIOClient.WireType.Fixed32">
            <summary>
            Fixed-length 4-byte encoding
            </summary>
        </member>
        <member name="M:PlayerIO.ServerCore.SocketLibrary.SocketListener.AddListener(System.Int32)">
            <summary>
            sets up listeners on all ips on the given port
            </summary>
        </member>
        <member name="T:PlayerIOClient.Connection">
             <summary>
             A connection into a running Player.IO multiplayer room
             <para>Here is an example of joining a multiplayer room and listening to all messages</para>
             <code>
             var client = PlayerIO.Connect(
             	"[Enter your game id here]",
             	"public",				
             	"user-id",			
             	null			
             );
             
             // join a multiplayer room
             var connection = client.Multiplayer.CreateJoinRoom(
            		"my-room-id", 
            		"bounce", 
            		true, 
            		null, 
            		null
            	);
             Console.WriteLine("Joined Multiplayer Room");
            
             // on message => print to console
             connection.OnMessage += delegate(object sender, PlayerIOClient.Message m) {
             	Console.WriteLine(m.ToString());
             };
            
             // when disconnected => print reason
             connection.OnDisconnect += delegate(object sender, string reason) {
            		Console.WriteLine("Disconnected, reason = " + reason);
             };
             </code>
             </summary>
        </member>
        <member name="M:PlayerIOClient.Connection.Disconnect">
            <summary>Disconnect from the game room</summary>
        </member>
        <member name="M:PlayerIOClient.Connection.Send(PlayerIOClient.Message)">
            <summary>Send a message to the connected client</summary>
            <param name="message">The message to send</param>
        </member>
        <member name="M:PlayerIOClient.Connection.Send(System.String,System.Object[])">
            <summary>
            Send a message to the connected client without first having to construct a Message object.
            </summary>
            <param name="type">The type of message to send</param>
            <param name="parameters">The data to put in the message to send</param>
        </member>
        <member name="E:PlayerIOClient.Connection.OnMessage">
            <summary>Event fired everytime a message is received.</summary>
        </member>
        <member name="E:PlayerIOClient.Connection.OnDisconnect">
            <summary>Event fired when the connection is disconnected.</summary>
        </member>
    </members>
</doc>
